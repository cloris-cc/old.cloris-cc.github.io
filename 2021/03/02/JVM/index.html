<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java虚拟机 (JVM) - 茶茶日记 - winklog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="茶茶日记 - winklog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="茶茶日记 - winklog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java 虚拟机知识点，总结自《深入理解Java虚拟机》"><meta property="og:type" content="blog"><meta property="og:title" content="Java虚拟机 (JVM)"><meta property="og:url" content="https://teamwang.cn/2021/03/02/JVM/"><meta property="og:site_name" content="茶茶日记 - winklog"><meta property="og:description" content="Java 虚拟机知识点，总结自《深入理解Java虚拟机》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/e9d672fff04da8c4-20211105143645529.jpeg"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/3d0974c5071c162d.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/T78Eah.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/8HW45I.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/7txkmK.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/ywaR8F.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/FcHyqE.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/UgKDNr.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/AY0KKc.png"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/452f3fa5c0066909.jpg"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/2df96e255f0e5e20.jpg"><meta property="og:image" content="https://uploader.shimo.im/f/AzbbP2cLFbDua1U7.png!thumbnail"><meta property="og:image" content="https://uploader.shimo.im/f/2ZuNZudQvF5F4ckN.png"><meta property="og:image" content="https://uploader.shimo.im/f/3hkjwRj7hr4qeTTq.png!thumbnail"><meta property="article:published_time" content="2021-03-01T20:23:54.000Z"><meta property="article:modified_time" content="2021-11-05T16:30:43.800Z"><meta property="article:author" content="Jacky"><meta property="article:tag" content="茶茶,日记,茶茶日记,winklog,WinkLog,博客,teamwang,TeamWang,王嘉尔,Jakcy,jacky"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/e9d672fff04da8c4-20211105143645529.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://teamwang.cn/2021/03/02/JVM/"},"headline":"Java虚拟机 (JVM)","image":["https://gitee.com/jacky_cloud/oss/raw/master/uPic/3d0974c5071c162d.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/T78Eah.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/8HW45I.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/7txkmK.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/ywaR8F.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/FcHyqE.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/UgKDNr.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/AY0KKc.png","https://gitee.com/jacky_cloud/oss/raw/master/uPic/452f3fa5c0066909.jpg","https://gitee.com/jacky_cloud/oss/raw/master/uPic/2df96e255f0e5e20.jpg","https://uploader.shimo.im/f/2ZuNZudQvF5F4ckN.png"],"datePublished":"2021-03-01T20:23:54.000Z","dateModified":"2021-11-05T16:30:43.800Z","author":{"@type":"Person","name":"Jacky"},"description":"Java 虚拟机知识点，总结自《深入理解Java虚拟机》"}</script><link rel="canonical" href="https://teamwang.cn/2021/03/02/JVM/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?05af3f3bd18ffe652b63cc7ee6abb48c";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="茶茶日记 - winklog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时光轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-01T20:23:54.000Z" title="3/2/2021, 4:23:54 AM">2021-03-02</time>发表</span><span class="level-item"><time dateTime="2021-11-05T16:30:43.800Z" title="11/6/2021, 12:30:43 AM">2021-11-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="level-item">1 小时读完 (大约10784个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java虚拟机 (JVM)</h1><div class="content"><p>Java 虚拟机知识点，总结自《深入理解Java虚拟机》</p>
<span id="more"></span>

<h1 id="1-JVM-结构"><a href="#1-JVM-结构" class="headerlink" title="1. JVM 结构"></a>1. JVM 结构</h1><p><strong>分为 4 部分：堆 + 栈 + 程序计数器 + 方法区/永久代(MetaSpace1.8)**。其中</strong>栈和程序计数器为线程私有**。</p>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/e9d672fff04da8c4-20211105143645529.jpeg" style="zoom: 50%;" />



<blockquote>
<p>A. <strong>程序计数器</strong></p>
</blockquote>
<ul>
<li>存放线程的<strong>字节码</strong>指令、分支、循环、异常处理等信息</li>
<li>唯一一处<strong>不会出现 OOM 异常</strong></li>
</ul>
<blockquote>
<p>B. <strong>虚拟机栈</strong></p>
</blockquote>
<ul>
<li><p>-Xss：设置栈大小</p>
</li>
<li><p>方法执行的时候创建<strong>栈帧</strong>(stack frame)，方法的调用其实就是<strong>栈帧</strong>出栈和入栈的过程</p>
</li>
<li><p>栈帧：如局部变量表等</p>
<ul>
<li>宽度：栈帧内存大小</li>
<li>虚拟机栈的深度：栈帧的数量</li>
</ul>
</li>
</ul>
<blockquote>
<p>B. <strong>本地方法栈</strong></p>
</blockquote>
<ul>
<li>调用的方法是本地(native)方法的接口，也就是C/C++程序</li>
</ul>
<blockquote>
<p>C. <strong>堆</strong></p>
</blockquote>
<p>存储对象及<strong>字符串</strong>（就是，占用空间大的数据）</p>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/3d0974c5071c162d.png" style="zoom:50%;" />

<p>上图说明了 <strong>FullGC</strong> 包括： <strong>MinorGC</strong>(在年轻代的Eden区) 和 <strong>MajorGC</strong>(在老年代)。但由于 MajorGC 占用了大部分的时间，所以一般将 MajorGC 与 FullGC 等价。</p>
<blockquote>
<p>D. <strong>方法区(永久代) / MetaSpace jdk1.8</strong></p>
</blockquote>
<ul>
<li><p>存储已经被JVM加载的类信息、<strong>常量 + static 变量</strong>、JIT(Just In Time)编译后的代码等数据（就是，占用空间小的数据）。</p>
<p>jdk1.7开始，字符串放到了堆中。</p>
</li>
</ul>
<h1 id="2-Thread-和-JVM-的关系"><a href="#2-Thread-和-JVM-的关系" class="headerlink" title="2. Thread 和 JVM 的关系"></a>2. Thread 和 JVM 的关系</h1><p>Java进程的内存大小(计算机内存为固定值) = *<em>堆内存 + 线程数量 * 栈内存*</em>，因为堆是线程共享，栈是线程私有的。</p>
<ul>
<li>故对固定内存大小的服务器来说，栈内存(-Xss)越大，其线程数量就越少。</li>
</ul>
<h1 id="3-JVM-的类加载器"><a href="#3-JVM-的类加载器" class="headerlink" title="3. JVM 的类加载器"></a>3. JVM 的类加载器</h1><p><strong>JVM 内置三大类加载器</strong></p>
<p>BootStrap CL &lt;&lt; Extend CL &lt;&lt; Application CL，遵循 <strong>双亲(或父)委托机制</strong></p>
<p>根加载器负责<strong>虚拟机核心类库</strong>的加载；拓展加载器负责加载JAVA_HOME下jre\lb\ext下子目录的类库，系统类加载器负责加载classpath下的类库资源。</p>
<p><strong>class 被加载后的内存情况</strong></p>
<table>
<thead>
<tr>
<th>栈内存（指针）</th>
<th>堆</th>
<th>方法区</th>
</tr>
</thead>
<tbody><tr>
<td>ClassLoader 的引用</td>
<td>ClassLoader 对象</td>
<td></td>
</tr>
<tr>
<td>A class 对象的引用</td>
<td>A 的 class 对象</td>
<td>A 类的数据结构</td>
</tr>
<tr>
<td>对象的引用</td>
<td>A 对象</td>
<td></td>
</tr>
</tbody></table>
<h1 id="4-Images"><a href="#4-Images" class="headerlink" title="4. Images"></a>4. Images</h1><h2 id="4-1-Java-堆溢出"><a href="#4-1-Java-堆溢出" class="headerlink" title="4.1 Java 堆溢出"></a>4.1 Java 堆溢出</h2><p><strong>如何 Dump OOM 日志？</strong></p>
<p>通过设置jvm参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>，可以让虚拟机在出现 OOM 异常时 Dump 内存堆转储快照</p>
<p><strong>发生OOM的处理方法？</strong></p>
<p>OOM &gt;&gt; 判断内存中的对象是否有用 &gt;&gt; 内存溢出(有) || 内存泄漏 Leak (无)</p>
<p><strong>如何定位内存泄漏代码？</strong></p>
<p>通过工具查看泄漏对象到 <strong>GC Root</strong> 的引用链，就可以定位世漏代码的位置</p>
<p><strong>GC Root 对象有哪些？</strong></p>
<p>虚拟机栈(栈帧中的本地变量表)引用的对象、本地方法栈 JNI (Java Native Interface) 引用的对象、方法区中的 static 变量和常量引用的对象。（栈+方法区）</p>
<h2 id="4-2-触发-GC-的条件"><a href="#4-2-触发-GC-的条件" class="headerlink" title="4.2 触发 GC 的条件"></a>4.2 触发 GC 的条件</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当 Head/YoungGen/// Eden 区满时触发</p>
<h3 id="Full-Major-GC"><a href="#Full-Major-GC" class="headerlink" title="Full/Major GC"></a>Full/Major GC</h3><ol>
<li>调用 System.gc() 方法 (不一定马上执行，和线程的原理一样)</li>
<li><strong>老年代空间不足（根本原因）</strong></li>
<li>方法区空间不足</li>
</ol>
<p>写完就轻松很多啦，就剩下一篇Springcloud了……</p>
<h3 id="判断对象是否“死亡”"><a href="#判断对象是否“死亡”" class="headerlink" title="判断对象是否“死亡”"></a>判断对象是否“死亡”</h3><p>有两种方法：</p>
<ol>
<li>引用计数法（已弃用）。因为当两者互相引用时，即使给它们赋值null，引用次数也永远不为 0。</li>
<li>可达性分析。如果<strong>两次</strong>机会 GC Root 向下搜索都无法达到该对象，则说明对象已“死亡”，为可回收对象。</li>
</ol>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/T78Eah.png" alt="T78Eah" style="zoom: 33%;" />

<h3 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h3><p>强引用 (new)：不被回收</p>
<p>软引用 (SoftReference)：OOM前回收</p>
<p>弱引用 (WeakReference)：下次GC回收</p>
<p>虚引用 (PhantomReference)：anytime</p>
<h2 id="4-3-四种垃圾回收算法"><a href="#4-3-四种垃圾回收算法" class="headerlink" title="4.3 四种垃圾回收算法"></a>4.3 四种垃圾回收算法</h2><ul>
<li>标记-清除：会产生<strong>内存碎片</strong>，并且分配较大对象时内存没有足够的连续空间时，会提前触发GC</li>
<li>复制算法：复制Eden区的存活对象到保留区域Survivor区后再整片清除。该算法不能在老年代使用是因为复制老年代的对象会造成巨大的空间占用和浪费</li>
<li>标记-整理：让存活的对象向一端移动，再直接清理掉边界外的内存数据。适用于老年代👴</li>
<li>分代收集算法：将内存分为几块区域各自选择合适的算法</li>
</ul>
<h2 id="4-4-垃圾回收器"><a href="#4-4-垃圾回收器" class="headerlink" title="4.4 垃圾回收器"></a>4.4 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130992385">垃圾回收器</a></h2><p>前仆后继，最好把每个版本的回收器都写出来</p>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/8HW45I.png" alt="8HW45I" style="zoom: 33%;" />

<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/7txkmK.png" alt="7txkmK" style="zoom:50%;" />

<h3 id="串行回收器组合"><a href="#串行回收器组合" class="headerlink" title="串行回收器组合"></a>串行回收器组合</h3><blockquote>
<p><strong>Serial + Serial Old</strong>，开启选项：-XX:+SerialGC</p>
</blockquote>
<p>串行收集器采用<strong>单线程 STW</strong>(stop-the-world) 的方式进行收集</p>
<h3 id="并行回收器组合"><a href="#并行回收器组合" class="headerlink" title="并行回收器组合"></a>并行回收器组合</h3><blockquote>
<p><strong>Parallel Scavenge + Parallel Old</strong>，开启选项：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC (可互相激活)</p>
</blockquote>
<p>并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集</p>
<h3 id="并发标记清除回收器组合"><a href="#并发标记清除回收器组合" class="headerlink" title="并发标记清除回收器组合"></a>并发标记清除回收器组合</h3><blockquote>
<p><strong>ParNew + CMS + Serial Old</strong>，JDK8 默认配置，开启选项：-XX:+UseConcMarkSweepGC</p>
<p>concurrent 不等于 parallel</p>
</blockquote>
<p>并发标记清除(CMS)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。</p>
<p><strong>ParNew</strong> 回收器相当于 Serial 的多线程版本，Parallel Scavenge (<strong>并行</strong>打扫) 回收器的目标是达到一个可控制的吞吐量(Throughput, TPS)。例如，JVM 运行 100 分钟，其中垃圾回收器运行占 1 分钟(STW)，则吞吐量为 99%。</p>
<p><strong>CMS</strong>(Concurrent Mark-Sweep) 回收器工作过程：1.初始标记 <strong>2.并发标记</strong> 3.重新标记 <strong>4.并发清除</strong></p>
<ol>
<li>初始标记：标记 GCRoots 能<strong>直接关联</strong>到的对象</li>
<li>并发标记：GCRoots Tracing 的过程，时间最长</li>
<li>重新标记：修正上一阶段因用户程序同时运行而导致标记变化的那一部份对象的标记记录</li>
<li>并发清除：略</li>
</ol>
<p>CMS 也称并发停顿回收器，但有 3 个缺点：</p>
<ol>
<li><p>对 CPU 资源敏感。CMS 默认启动的线程数量为 (CPU 数量 + 3)/4。当 CPU 数量少于 4 个时，CMS对用户程序的影响可能更大。(其实就是 cpu 核数少导致线程少导致回收时间变长？)</p>
</li>
<li><p>CMS 回收器无法处理<strong>浮动垃圾</strong>（Floating Garbage），即 CMS 并发清除阶段时用户线程继续运行产生的新垃圾。故 CMS 不能像其它回收器一样等到老年代空间不足再收集，需要预留空间。若空间不足则会进行一次FullGC(STW)。对象还是放不下就会出现 <code>Concurrent Mode Failure</code>异常。</p>
</li>
<li><p>CMS 回收器是基于标记-清除算法，所以会产生内存碎片。虽然不会因为<strong>碎片</strong>导致提前FullGC，因为CMS会在FullGC前提前整理<strong>压缩内存碎片</strong>。但是无论如何，该算法的效率(指加上整理碎片的时间后)并不高。</p>
</li>
</ol>
<h3 id="Garbage-First-G1"><a href="#Garbage-First-G1" class="headerlink" title="Garbage First (G1)"></a>Garbage First (G1)</h3><blockquote>
<p>在 jdk7 版本其实就有了，直到 jdk9 才成为默认配置</p>
</blockquote>
<p><strong>G1</strong>：与 CMS 回收器类似，如并发，运行过程。但主要有以下两个优点：</p>
<ol>
<li>基于“分代收集算法”，其实就是 YoungGen 使用复制算法；OldGen 使用标记-整理算法，<strong>不会产生内存碎片</strong>。</li>
<li>G1的设计原则是”<strong>优先回收最多垃圾的一块区域(Garbage - First)</strong>“。G1 将内存划分一个个固定大小的 region 区域，region 可以位于年轻代或老年代。内存的回收是以 region 作为基本单位的，G1不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，找出具有高收集收益的 Region 区域进行收集。</li>
</ol>
<h2 id="4-5-GC-日志"><a href="#4-5-GC-日志" class="headerlink" title="4.5 GC 日志"></a>4.5 GC 日志</h2><img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/ywaR8F.png" alt="ywaR8F" style="zoom:50%;" />

<p>日志首行的GC指的是YoungGen发生的 Minor GC，而FullGC是有停顿的STW的GC。</p>
<h2 id="4-6-内存分配策略"><a href="#4-6-内存分配策略" class="headerlink" title="4.6 内存分配策略"></a>4.6 内存分配策略</h2><p>分配策略：对象优先在堆-年轻代的Eden区分配。大对象直接进入老年代，如长字符串，数组等；长期存活的对象将进入堆中的老年代。</p>
<p>空间分配担保：gc 时若 S1 空间不够放 Eden 区复制过来的数据时，则把数据复制到老年代中(即由老年代担保)。若老年代空间也不足则进行STW的FullGC。</p>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/FcHyqE.png" alt="FcHyqE" style="zoom:50%;" />

<h2 id="4-7-ClassLoader-类加载器"><a href="#4-7-ClassLoader-类加载器" class="headerlink" title="4.7 ClassLoader 类加载器"></a>4.7 ClassLoader 类加载器</h2><img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/UgKDNr.png" alt="UgKDNr" style="zoom: 67%;" />

<p>双亲委派模型的作用：保证 Object 类在程序中的各种类加载器环境中都是同一个类。因为即使是同一个类，被不同的ClassLoader加载，也会成为两个完全不同的类。</p>
<p>双亲委派模型的工作过程：类加载器会一直委派父加载器去加载类，直到父加载器无法加载时才会自己尝试(第一次)去加载。</p>
<h2 id="4-8-剩下的图片"><a href="#4-8-剩下的图片" class="headerlink" title="4.8 剩下的图片"></a>4.8 剩下的图片</h2><p>limit 3, 5 其中 3 是数组下标，表示第四条数据。</p>
<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/AY0KKc.png" alt="AY0KKc" style="zoom: 50%;" />

<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/452f3fa5c0066909.jpg" style="zoom:67%;" />

<img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/2df96e255f0e5e20.jpg" style="zoom:67%;" />

<h1 id="5-配置-amp-调优"><a href="#5-配置-amp-调优" class="headerlink" title="5. 配置&amp;调优"></a>5. 配置&amp;调优</h1><p><strong>配置说明</strong></p>
<p>-Xmx：最大堆大小<br>-Xms：初始堆大小<br>-Xmn:年轻代大小（n：New generation）<br>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值（一般对象放Eden区，S区是辅助）</p>
<ul>
<li>为避免频繁GC，可将堆的初始值最大值改为相等。（-Xms &amp; -Xmx）</li>
</ul>
<p>这是默认的 IDEA 配置 (jdk8, idea.vmoptions 文件):</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xms128m</span></span><br><span class="line"><span class="attr">-Xmx1024m</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">ReservedCodeCacheSize=512m</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseConcMarkSweepGC // CMS 垃圾回收器</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">SoftRefLRUPolicyMSPerMB=50</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CICompilerCount=2</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">-OmitStackTraceInFastThrow</span></span><br><span class="line"><span class="attr">-ea</span></span><br><span class="line"><span class="meta">-Dsun.io.useCanonCaches</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">-Djdk.http.auth.tunneling.disabledSchemes</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">-Djdk.attach.allowAttachSelf</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">-Djdk.module.illegalAccess.silent</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">-Dkotlinx.coroutines.debug</span>=<span class="string">off</span></span><br><span class="line"></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">ErrorFile=$USER_HOME/java_error_in_idea_%p.log</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">HeapDumpPath=$USER_HOME/java_error_in_idea.hprof</span></span><br></pre></td></tr></table></figure>

<h1 id="6-Java-版本"><a href="#6-Java-版本" class="headerlink" title="6. Java 版本"></a>6. Java 版本</h1><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://shimo.im/docs/hW6ddKDwt6YPJkDD/read">https://shimo.im/docs/hW6ddKDwt6YPJkDD/read</a></p>
</blockquote>
<h2 id="6-1-发布日期"><a href="#6-1-发布日期" class="headerlink" title="6.1 发布日期"></a>6.1 发布日期</h2><p>JDK 1.0</p>
<ul>
<li>1996-01-23 发布</li>
</ul>
<p>JDK 1.1</p>
<ul>
<li>1997-02-19 发布</li>
</ul>
<p>JDK 1.2</p>
<ul>
<li>1998-12-04 发布</li>
</ul>
<p>JDK 1.3</p>
<ul>
<li>2000-05-08 发布</li>
</ul>
<p>JDK 1.4</p>
<ul>
<li>2002-02-13 发布<br>正则表达式，异常链，NIO，日志类，XML解析器，XLST 转换器</li>
</ul>
<p>JDK 1.5/5.0</p>
<ul>
<li>2004-09-30 发布<br>自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环</li>
</ul>
<p>JDK 1.6/6.0</p>
<ul>
<li>2006-04 提供动态语言支持、提供编译 API 和卫星 HTTP 服务器 API，改进 JVM 的锁，同步垃圾回收，类加载</li>
</ul>
<p>JDK 1.7/7.0</p>
<ul>
<li>2011-07-28 发布<br>提供GI回收器、加强对非Java语言的调用支持（JSR-292,升级类加载架构</li>
</ul>
<p>JDK 1.8/8.0</p>
<ul>
<li>2014-03-18 发布<br>Lambda 表达式、方法引用、默认方法、新工具、Stream API、Date Time API 、Optional 类、Nashorn, JavaScript 引擎</li>
</ul>
<p>JDK 9.0</p>
<ul>
<li>2017-09-21 发布<br>JShell、不可变集合工厂方法、模块系统、http协议2.0版本、Process API/CompletableFuture API/Optional Class/Stream API增强、匿名内部类的钻石操作符、默认G1垃圾回收器、try语句语法改进</li>
</ul>
<p>JDK 10.0</p>
<ul>
<li>2018-03-21 发布<br>JIT 编译器、局部变量类型引用、数据类型共享、并行GC、root 证书、javah工具、堆分配</li>
</ul>
<p>JDK 11.0</p>
<ul>
<li>2018-09-25 发布<br>单命令运行Java文件、Lambda 参数局部变量语法、基于嵌套访问控制、动态类文件常量、误操作垃圾回收器、删除Java EE和 CORBA 模块、ChaCha20与Poly1305加密算法、Aarch64增强、ZGC试用、弃用 Nashorn JS引擎</li>
</ul>
<p>JDK 12.0</p>
<ul>
<li>2019-03-19 发布<br>JVM 增强、Switch 表达式、文件 mismatch() 方法、String 新方法 indent()/transform()/describeConstable()/resolveConstantDesc()、JVM常量API、instanceof 模式匹配</li>
</ul>
<p>JDK 13.0</p>
<ul>
<li>2019-09-17 发布<br>支持编写文本块、Switch 表达式增强、重构遗留的 Socket API、取消提交未使用内存、动态CDS存档、支持Unicode 12.1、DOM 和 SAX 工厂支持命名空间</li>
</ul>
<p>JDK 14.0</p>
<ul>
<li>2020-03-17 发布<br>空指针异常增强提示、Switch 表达式（标准）、instanceof 模式匹配（预览）、Records 类（预览）、文本块（第二次预览）、打包工具（孵化）、JFR 事件流、ZGC ( 支持 macOS 和 Windows )、外部存储器访问API（孵化）</li>
</ul>
<p>JDK 15.0</p>
<ul>
<li>2020-09-15 发布<br>密封类（预览）、instanceof 模式匹配（第二次预览）、Records 类（第二次预览）、文本块（标准）、隐藏类、删除 Nashorn JS引擎、重构遗留的 DatagramSocket API、外部存储器访问API（第二次孵化）、弃用RMI激活、移除 Solaris 和 SPARC 的端口</li>
</ul>
<p>JDK 16.0</p>
<ul>
<li>2020-12-10 第一次提案冻结<br>2021-01-14 第二次提案冻结<br>2021-02-04 发布第一个预览版本<br>2021-02-18 发布第二个预览版本<br>2021-03-16 正式发布</li>
</ul>
<p>JDK 17.0</p>
<ul>
<li>2021-09-15 正式发布</li>
</ul>
<h2 id="6-2-JDK-9-17-功能特性"><a href="#6-2-JDK-9-17-功能特性" class="headerlink" title="6.2 JDK 9~17 功能特性"></a>6.2 JDK 9~17 功能特性</h2><blockquote>
<p>java 9: G1</p>
<p>java 11: ZGC</p>
</blockquote>
<h3 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h3><p>最大特性是引入了模块化机制，并把之前的rt.jar做了拆分。</p>
<p>在Java9之后引入了模块化的概念，是将类型和资源封装在模块中，并仅导出其他模块要访问其公共类型的软件包。如果模块中的软件包未导出或打开，则表示模块的设计人员无意在模块外部使用这些软件包。 这样的包可能会被修改或甚至从模块中删除，无需任何通知。 如果仍然使用这些软件包通过使用命令行选项导出或打开它们，可能会面临破坏应用程序的风险！</p>
<p>以下几个包变成了独立的jar依赖：</p>
<p>JAF(javax.activation）</p>
<p>CORBA(java.corba)</p>
<p>JTA (java.transaction)</p>
<p>JAXB和JAX-WS</p>
<p>Common Annotations</p>
<p>项目中如果有使用，需要添加引用。</p>
<p>ClassLoader变化带来的URLClassLoader的变化</p>
<ol>
<li>Java 8的ClassLoader流程：</li>
</ol>
<p>bootstrap classloader加载rt.jar，jre/lib/endorsedext classloader加载jre/lib/extapplication classloader加载-cp指定的类</p>
<ol>
<li>java9及之后的classloader流程：</li>
</ol>
<p>bootstrap classloader加载lib/modulesext classloader更名为platform classloader，加载lib/modulesapplication classloader加载-cp，-mp指定的类同时，我们注意到，JDK9开始，AppClassLoader他爹不再是 URLClassLoader</p>
<h3 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h3><p>最大特点是改进并行全垃圾回收器 G1。</p>
<p>大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。</p>
<p>G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。Java 10 中采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：-XX:ParallelGCThreads 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数</p>
<p>基于 Java 的 实验性 JIT 编译器：Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）。</p>
<p>Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。</p>
<p>Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：</p>
<p>-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler</p>
<h3 id="JDK11（LTS）"><a href="#JDK11（LTS）" class="headerlink" title="JDK11（LTS）"></a>JDK11（LTS）</h3><p>最大变化时Linux版本新增了ZGC。</p>
<p>ZGC在Linux x64下的JDK11以上可用，Mac和Windows上需要JDK15可用。</p>
<p>Java11 ZGC实测gc时间稳定在3ms左右（当然也许跟场景有关，官方口径一般在10ms以下）。</p>
<p>ZGC：这应该是JDK11最为瞩目的特性，没有之一。但是后面带了Experimental，说明还不建议用到生产环境。看看官方对这个特性的目标描述：</p>
<ul>
<li><p>GC暂停时间不会超过10ms；</p>
</li>
<li><p>即能处理几百兆小堆，也能处理几个T的大堆（OMG）；</p>
</li>
<li><p>和G1相比，应用吞吐能力不会下降超过15%；</p>
</li>
<li><p>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础；</p>
</li>
<li><p>初始只支持64位系统；</p>
</li>
</ul>
<p>GC是Java主要优势之一。然而，当GC停顿太长，就会开始影响应用的响应时间。消除或者减少GC停顿时长，Java将对更广泛的应用场景是一个更有吸引力的平台。此外，现代系统中可用内存不断增长， 用户和程序员希望JVM能够以高效的方式充分利用这些内存，并且无需长时间的GC暂停时间。 ZGC一个并发，基于region，压缩型的垃圾收集器，只有root扫描阶段会STW，因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。 ZGC和G1停顿时间比较：</p>
<p>Plain Text</p>
<p>ZGC </p>
<p>avg: 1.091ms (+/-0.215ms) </p>
<p>95th percentile: 1.380ms </p>
<p>99th percentile: 1.512ms </p>
<p>99.9th percentile: 1.663ms </p>
<p>99.99th percentile: 1.681ms </p>
<p>max: 1.681ms </p>
<p>G1 </p>
<p>avg: 156.806ms (+/-71.126ms)</p>
<p>95th percentile: 316.672ms</p>
<p>99th percentile: 428.095ms</p>
<p>99.9th percentile: 543.846ms</p>
<p>99.99th percentile: 543.846ms</p>
<p>max: 543.846ms</p>
<p>用法：</p>
<p>Plain Text</p>
<p>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</p>
<p>因为ZGC还处于实验阶段，所以需要通过JVM参数UnlockExperimentalVMOptions 来解锁这个特性。</p>
<p><img src="https://uploader.shimo.im/f/AzbbP2cLFbDua1U7.png!thumbnail" alt="img"></p>
<p>不过目前 ZGC 还处于实验阶段，目前只在 Linux/x64 上可用，如果有足够的需求，将来可能会增加对其他平台的支持。同时作为实验性功能的 ZGC 将不会出现在 JDK 构建中，除非在编译时使用 configure 参数：–with-jvm-features=zgc 显式启用。</p>
<p>在实验阶段，编译完成之后，已经迫不及待的想试试 ZGC，需要配置以下 JVM 参数，才能使用 ZGC，具体启动 ZGC 参数如下：</p>
<p>-XX：+ UnlockExperimentalVMOptions -XX：+ UseZGC -Xmx10g</p>
<p>其中参数：-Xmx 是 ZGC 收集器中最重要的调优选项，大大解决了程序员在 JVM 参数调优上的困扰。ZGC 是一个并发收集器，必须要设置一个最大堆的大小，应用需要多大的堆，主要有下面几个考量：</p>
<p>- 对象的分配速率，要保证在 GC 的时候，堆中有足够的内存分配新对象。</p>
<p>- 一般来说，给 ZGC 的内存越多越好，但是也不能浪费内存，所以要找到一个平衡。</p>
<p>Java11中还新引入的Epsilon–神兽貔貅一般只吃不拉，所以就不回收和释放内存，非常适合用来做性能分析。</p>
<p>Epsilon垃圾回收器的目标是开发一个控制内存分配，但是不执行任何实际的垃圾回收工作。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。</p>
<p>Java 版本中已经包含了一系列的高度可配置化的 GC 实现。各种不同的垃圾回收器可以面对各种情况。但是有些时候使用一种独特的实现，而不是将其堆积在其他 GC 实现上将会是事情变得更加简单。</p>
<p>Epsilon 垃圾回收器和其他垃圾回收器一样，可以通过参数-XX:+UseEpsilonGC 开启。</p>
<h3 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h3><p>Java 12 中引入一个新的垃圾收集器：Shenandoah，它是作为一中低停顿时间的垃圾收集器而引入到 Java 12 中的，其工作原理是通过与 Java 应用程序中的执行线程同时运行，用以执行其垃圾收集、内存回收任务，通过这种运行方式，给虚拟机带来短暂的停顿时间。</p>
<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目，旨在针对 JVM 上的内存收回实现低停顿的需求。该设计将与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在大多数 JVM 垃圾收集器中所遇到的问题。</p>
<p>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://uploader.shimo.im/f/2ZuNZudQvF5F4ckN.png" alt="img"></p>
<p>Shenandoah在Linux x64下的JDK12以上可用（在由Red Hat 公司发行的Linux版本redhat/centos上，可以backport到JDK8的高版本），Mac和Windows上需要JDK15可用。</p>
<p>Shennadoah工作周期如下：</p>
<p>Init Mark 启动并发标记 阶段并发标记遍历堆阶段并发标记完成阶段并发整理回收无活动区域阶段并发 Evacuation 整理内存区域阶段Init Update Refs 更新引用初始化 阶段并发更新引用阶段Final Update Refs 完成引用更新阶段并发回收无引用区域阶段需要了解不是唯有 GC 停顿可能导致常规应用程序响应时间比较长。具有较长的 GC 停顿时间会导致系统响应慢的问题，但响应时间慢并非一定是 GC 停顿时间长导致的，队列延迟、网络延迟、其他依赖服务延迟和操作提供调度程序抖动等都可能导致响应变慢。</p>
<p>使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。各种 GC 工作负载对比如下所示：</p>
<p><img src="https://uploader.shimo.im/f/3hkjwRj7hr4qeTTq.png!thumbnail" alt="img"></p>
<p>推荐几个配置或调试 Shenandoah 的 JVM 参数:</p>
<ol>
<li><p>-XX:+AlwaysPreTouch：使用所有可用的内存分页，减少系统运行停顿，为避免运行时性能损失。</p>
</li>
<li><p>-Xmx == -Xms：设置初始堆大小与最大值一致，可以减轻伸缩堆大小带来的压力，与 AlwaysPreTouch 参数配合使用，在启动时提交所有内存，避免在最终使用中出现系统停顿。</p>
</li>
<li><p>-XX:+ UseTransparentHugePages：能够大大提高大堆的性能，同时建议在 Linux 上使用时将 /sys/kernel/mm/transparent_hugepage/enabled 和 /sys/kernel/mm/transparent_hugepage/defragv 设置为：madvise，同时与 AlwaysPreTouch 一起使用时，init 和 shutdownv 速度会更快，因为它将使用更大的页面进行预处理。</p>
</li>
<li><p>-XX:+UseNUMA：虽然 Shenandoah 尚未明确支持 NUMA（Non-Uniform Memory Access），但最好启用此功能以在多插槽主机上启用 NUMA 交错。与 AlwaysPreTouch 相结合，它提供了比默认配置更好的性能。</p>
</li>
<li><p>-XX:+DisableExplicitGC：忽略代码中的 System.gc() 调用。当用户在代码中调用 System.gc() 时会强制 Shenandoah 执行 STW Full GC ，应禁用它以防止执行此操作，另外还可以使用 -XX:+ExplicitGCInvokesConcurrent，在 调用 System.gc() 时执行 CMS GC 而不是 Full GC，建议在有 System.gc() 调用的情况下使用。不过目前 Shenandoah 垃圾回收器还被标记为实验项目，需要使用参数：- XX:+UnlockExperimentalVMOptions 启用。更多有关如何配置、调试 Shenandoah 的信息，请参阅 henandoah wiki。</p>
</li>
</ol>
<p>注意，ZGC和Shenandoah GC都可以看做是Azul 公司提出的无停顿GC（Pauseless GC）的开源实现版本。</p>
<p>Java12中继续改善了G1 GC</p>
<p>G1 是垃圾收集器，设计用于具有大量内存的多处理器机器，提高了垃圾回收效率。该垃圾收集器 设计的主要目标之一是满足用户设置的预期的 JVM 停顿时间，G1 采用一个高级分析引擎来选择在收集期间要处理的工作量，此选择过程的结果是一组称为 GC 回收集的区域。一旦收集器确定了 GC 回收集 并且 GC 回收、整理工作已经开始，则 G1 收集器必须完成收集集合集的所有区域中的所有活动对象之后才能停止；但是如果收集器选择过大的 GC 回收集，可能会导致 G1 回收器停顿时间超过预期时间。</p>
<p>Java 12 中将把 GC 回收集（混合收集集合）拆分为必需和可选两部分，使 G1 垃圾回收器能中止垃圾回收过程。其中必需处理的部分包括 G1 垃圾收集器不能递增处理的 GC 回收集的部分（如：年轻代），同时也可以包含老年代以提高处理效率。将 GC 回收集拆分为必需和可选部分时，需要为可选 GC 回收集部分维护一些其他数据，这会产生轻微的 CPU 开销，但小于 1 ％的变化，同时在 G1 回收器处理 GC 回收集期间，本机内存使用率也可能会增加，使用上述情况只适用于包含可选 GC 回收部分的 GC 混合回收集合。</p>
<p>在 G1 垃圾回收器完成收集需要必需回收的部分之后，便开始收集可选的部分，如果还有时间的话，但是粗粒度的处理，可选部分的处理粒度取决于剩余的时间，一次只能处理可选部分的一个子集区域。在完成可选收集部分的收集后，G1 垃圾回收器可以根据剩余时间决定是否停止收集。如果在处理完 必需处理的 部分后，属于时间不足，总时间花销接近预期时间，G1 垃圾回收器也可以中止可选部分的回收以达到满足预期停顿时间的目标。</p>
<p>Java12增强G1 垃圾收集器：自动返回未用堆内存给操作系统</p>
<p>Java 12 中增强了 G1 垃圾收集器关于混合收集集合的处理策略，使其能够在空闲时自动将 Java 堆内存返还给操作系统，这也是 Java 12 中的另外一项重大改进。</p>
<p>目前 Java 11 版本中包含的 G1 垃圾收集器 暂时无法及时将已提交的 Java 堆内存返回给操作系统， G1 垃圾收集器仅在进行完整 GC (Full GC) 或并发处理周期时才能将 Java 堆返回内存。由于 G1 回收器尽可能避免完整 GC，并且只触发基于 Java 堆占用和分配活动的并发周期，因此在许多情况下 G 1 垃圾回收器不能回收 Java 堆内存，除非有外部强制执行。</p>
<p>在使用云平台的容器环境中，这种不利之处特别明显。即使在虚拟机不活动，但如果仍然使用其分配的内存资源，哪怕是其中的一小部分，G1 回收器也仍将保留所有已分配的 Java 堆内存。而这将导致用户需要始终为所有资源付费，哪怕是实际并未用到，而云提供商也无法充分利用其硬件。如果在次期间虚拟机能够检测到 Java 堆内存的实际使用情况，并在利用空闲时间自动将 Java 堆内存返还，则两者都将受益。</p>
<p>为了尽可能的向操作系统返回空闲内存，G1 垃圾收集器将在应用程序不活动期间定期生成或持续循环检查整体 Java 堆使用情况，以便 G 1 垃圾收集器能够更及时的将 Java 堆中不使用内存部分返还给操作系统。对于长时间处于空闲状态的应用程序，此项改进将使 JVM 的内存利用率更加高效。</p>
<p>如果应用程序为非活动状态，在下面两种情况下，G1 回收器会触发定期垃圾收集：</p>
<p>自上次垃圾回收完成 以来已超过 G1PeriodicGCInterva l 毫秒， 并且此时没有正在进行的垃圾回收任务。如果 G1PeriodicGCInterval 值为零表示禁用快速回收内存的定期垃圾收集。</p>
<p>应用所在主机系统上执行方法 getloadavg()，一分钟内系统返回的平均负载值低于 G1PeriodicGCSystemLoadThreshold。如果 G1PeriodicGCSystemLoadThreshold 值为零，则此条件不生效。</p>
<p>如果不满足上述条件中的任何一个，则取消当期的定期垃圾回收。等一个 G1PeriodicGCInterval 时间周期后，将重新考虑是否执行定期垃圾回收。</p>
<p>G1 定期垃圾收集的类型根据 G1PeriodicGCInvokesConcurrent 参数的值确定：如果设置值了，G1 垃圾回收器将继续上一个或者启动一个新并发周期；如果没有设置值，则 G1 回收器将执行一个完整的 GC。在每次一次 GC 回收末尾，G1 回收器将调整当前的 Java 堆大小，此时便有可能会将未使用内存返还给操作系统。新的 Java 堆内存大小根据现有配置确定，具体包括下列配置：- XX:MinHeapFreeRatio、-XX:MaxHeapFreeRatio、-Xms、-Xmx。</p>
<p>默认情况下，G1 回收器在定期垃圾回收期间新启动或继续上一轮并发周期，将最大限度地减少应用程序的中断。如果定期垃圾收集严重影响程序执行，则需要考虑整个系统 CPU 负载，或让用户禁用定期垃圾收集。</p>
<h3 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h3><p>Java13增强ZGC：释放未使用内存</p>
<p>ZGC 是 Java 11 中引入的最为瞩目的垃圾回收特性，是一种可伸缩、低延迟的垃圾收集器，不过在 Java 11 中是实验性的引入，主要用来改善 GC 停顿时间，并支持几百 MB 至几个 TB 级别大小的堆，并且应用吞吐能力下降不会超过 15%，目前只支持 Linux/x64 位平台的这样一种新型垃圾收集器。</p>
<p>通过在实际中的使用，发现 ZGC 收集器中并没有像 Hotspot 中的 G1 和 Shenandoah 垃圾收集器一样，能够主动将未使用的内存释放给操作系统的功能。对于大多数应用程序来说，CPU 和内存都属于有限的紧缺资源，特别是现在使用的云上或者虚拟化环境中。如果应用程序中的内存长期处于空闲状态，并且还不能释放给操作系统，这样会导致其他需要内存的应用无法分配到需要的内存，而这边应用分配的内存还处于空闲状态，处于”忙的太忙，闲的太闲”的非公平状态，并且也容易导致基于虚拟化的环境中，因为这些实际并未使用的资源而多付费的情况。由此可见，将未使用内存释放给系统主内存是一项非常有用且亟需的功能。</p>
<p>ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 ZPageCache 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织。在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用。同时释放这些未使用的内存给操作系统不会导致堆大小缩小到参数设置的最小大小以下，如果将最小和最大堆大小设置为相同的值，则不会释放任何内存给操作系统。</p>
<p>Java 13 中对 ZGC 的改进，主要体现在下面几点：</p>
<ul>
<li><p>释放未使用内存给操作系统</p>
</li>
<li><p>支持最大堆大小为 16TB</p>
</li>
<li><p>添加参数：-XX:SoftMaxHeapSize 来软限制堆大小</p>
</li>
</ul>
<p>这里提到的是软限制堆大小，是指 GC 应努力是堆大小不要超过指定大小，但是如果实际需要，也还是允许 GC 将堆大小增加到超过 SoftMaxHeapSize 指定值。主要用在下面几种情况：当希望降低堆占用，同时保持应对堆空间临时增加的能力，亦或想保留充足内存空间，以能够应对内存分配，而不会因为内存分配意外增加而陷入分配停滞状态。不应将 SoftMaxHeapSize 设置为大于最大堆大小（-Xmx 的值，如果未在命令行上设置，则此标志应默认为最大堆大小。</p>
<p>Java 13 中，ZGC 内存释放功能，默认情况下是开启的，不过可以使用参数：-XX：-ZUncommit 显式关闭，同时如果将最小堆大小 (-Xms) 配置为等于最大堆大小 (-Xmx)，则将隐式禁用此功能。</p>
<p>还可以使用参数：-XX：ZUncommitDelay = <seconds>（默认值为 300 秒）来配置延迟释放，此延迟时间可以指定释放多长时间之前未使用的内存。</p>
<h3 id="JDK14"><a href="#JDK14" class="headerlink" title="JDK14"></a>JDK14</h3><p>感觉变化不大。</p>
<p>加入了java打包工具jpackage的预览版。</p>
<p>加入了类似kotlin中的data object的数据类型：记录Record（<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/359%EF%BC%89%EF%BC%9A">https://openjdk.java.net/jeps/359）：</a></p>
<blockquote>
<p>record Point(int x, int y) { }</p>
</blockquote>
<p>参见：<a target="_blank" rel="noopener" href="https://www.infoworld.com/article/3436795/jdk-14-the-new-features-in-java-14.html">https://www.infoworld.com/article/3436795/jdk-14-the-new-features-in-java-14.html</a></p>
<h3 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h3><p>ZGC将从实验功能升级为产品。ZGC已集成到2018年9月发布的<a href="https://link.zhihu.com/?target=https://www.infoworld.com/article/3265447/java-jdk-11-all-the-new-features-now-available.html">JDK 11中</a>，是一个可扩展的低延迟垃圾回收器。引入ZGC是一项实验功能，因为Java的开发人员决定应谨慎而逐步地引入这种大小和复杂性的功能。从那时起，已经添加了许多改进，从并发类卸载，未使用内存的未提交，对数据类共享的支持到改进的NUMA感知和多线程堆预触。此外，最大堆大小已从4 TB增加到16 TB。支持的平台包括Linux，Windows和MacOS。</p>
<p>同样的，还有Shenandoah GC。</p>
<p>参见：<a target="_blank" rel="noopener" href="https://www.infoworld.com/article/3534133/jdk-15-the-new-features-in-java-15.html">https://www.infoworld.com/article/3534133/jdk-15-the-new-features-in-java-15.html</a></p>
<h3 id="JDK16"><a href="#JDK16" class="headerlink" title="JDK16"></a>JDK16</h3><p>1）最大的变化就是引入Record，Records 就是一种新的语法糖，目的还是为了简化代码，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。熟悉kotlin的同学，可以看做是data object类。</p>
<p>Records 可以在一定程度上避免低级冗余的代码，比如：constructors, getters, equals(), hashCode(), toString() 方法等，相当于 Lombok 的 <code>@Data</code> 注解，但又不能完全替代。</p>
<p>下面来看一个示例：</p>
<p>Plain Text</p>
<p>public record Student(String name, int id, int age) {}</p>
<p>这样就完成 完成了整个pojo类的定义。</p>
<p>2）JDK16 将提供一款名为 jpackage 的工具，用于独立打包 Java 应用程序。</p>
<p>jpackage 在 JDK 14 中被作为孵化工具引入，并在 JDK 15 中仍处于孵化阶段。到了JDK 16，jpackage 将投入生产，支持本地的软件包格式，从而为用户提供自然的安装体验，并允许在打包时指定启动时参数。支持的格式包括 Windows 上的 msi 和 exe ，MacOS 上的 pkg 和 dmg 以及 Linux 上的 deb 和 rpm 。该工具可以直接从命令行或以编程方式调用。新的打包工具解决了这样一种情况：许多Java应用程序需要以全局可用的方式安装在本机平台上，而不是简单地放置在类路径或模块路径上。因此提供适合本机平台的可安装软件包非常有必要。</p>
<p><a target="_blank" rel="noopener" href="https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html">参见：https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html</a></p>
<p>3）Pattern Matching for instanceof</p>
<p>模式匹配 for instanceof，相当于是增强的 instanceof，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p>
<p>模式匹配的到来将使得 instanceof 变得更简洁、更安全，为什么这么说，请看下面的示例。</p>
<p><strong>正常的 instanceof 写法：</strong></p>
<p>Plain Text</p>
<p>if (object instanceof Kid) {</p>
<p>Kid kid = (Kid) object;</p>
<p>// …</p>
<p>} else if (object instanceof Kiddle) {</p>
<p>Kid kid = (Kid) object;</p>
<p>// …</p>
<p>}</p>
<p><strong>模式匹配的 instanceof 写法：</strong></p>
<p>Plain Text</p>
<p>if (object instanceof Kid kid) {</p>
<p>// …</p>
<p>} else if (object instanceof Kiddle kiddle) {</p>
<p>// …</p>
<p>}</p>
<p>此外，还把openjdk源码迁移到了github。</p>
<p>参见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/javastack/p/14583578.html">https://www.cnblogs.com/javastack/p/14583578.html</a></p>
<h3 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h3><p>1）增强了伪随机数算法。</p>
<p>2）移除AOT提前编译和JIT即时编译的功能，Oracle JDK16 未包含此功能。</p>
<p>3）sealed修饰的类和接口限制其他的类或者接口的扩展和实现。说白了就是限制类的继承或者接口的实现数量。</p>
<p>4）进一步增强了switch语法的模式匹配，万物皆可switch下使用了。</p>
<p>此版本的变化较小。</p>
<h2 id="6-3-JDK版本机制"><a href="#6-3-JDK版本机制" class="headerlink" title="6.3 JDK版本机制"></a>6.3 JDK版本机制</h2><p>Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。</p>
<p>当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。</p>
<p>不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：</p>
<p>$FEATURE.$INTERIM.$UPDATE.$PATCH</p>
<p>$FEATURE，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。</p>
<p>$INTERIM，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。</p>
<p>目前JDK每半年升一个大版本，其中JDK8和11是LTS长期维护版本，8的维护周期预计比11还要长。下一个可能是JDK17（大概会在2021年的Q3发布）。期望8以后，大家直接升级到17。</p>
<blockquote>
<p>每六个月发布一个大更新（就是每年的3月还有9月）</p>
</blockquote>
<blockquote>
<p>对于每个大版本更新，会有两次小版本更新（在发布后一个月或者四个月之后）</p>
</blockquote>
<p>OpenJDK已可以作为新的线上标准JDK</p>
<blockquote>
<p>在2018.9之前，Oracle JDK是大家普遍运用于线上的JDK，OpenJDK的特性并不完全，并且Oracle JDK号称做了很多优化。在2018.9之后，Oracle JDK正式商用（开发不收费，但是运行线上业务收费）。但是与此同时，Oracle宣布，OpenJDK与Oracle JDK在功能上不会有区别。并且，OpenJDK 11 RTS将会由红帽社区进行维护。这样，更加增加了可靠性与保证问题的及时解决。</p>
</blockquote>
<p>2021-9-15 JDK17发布的同时，Oracle JDK宣布免费。</p>
<h2 id="6-4-Oracle免费JDK"><a href="#6-4-Oracle免费JDK" class="headerlink" title="6.4 Oracle免费JDK"></a>6.4 Oracle免费JDK</h2><p>Oracle JDK收费一直被好多人吐槽，这次是推出了Free Java License 大致摘要：</p>
<ul>
<li><p>Oracle 长在免费提供JDK，包括所有季度安全更新，其中也包括商业和生产用途。</p>
</li>
<li><p>本次Oracle JDK许可证允许所有用户免费使用，再分发也允许；</p>
</li>
<li><p>程序员和企业现在无需点击即可轻松下载、使用、共享和重新分发 Oracle JDK。</p>
</li>
<li><p>Oracle 将从Oracle JDK 17开始提供这些免费版本和更新，并在下一个 LTS 版本之后继续提供整整一年。以前的版本不受此更改的影响。</p>
</li>
<li><p>Oracle 将继续按照自 Java 9 以来的相同版本和时间表提供GPL下的Oracle OpenJDK 版本。</p>
</li>
</ul>
<p>解释一下目前在免费许可证下可以商用，其次就是Spring也官宣了，明年发布的Spring framework 6 和Spring Boot 3 都将基于JAVA 17，大家还要坚守Java8吗？</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java虚拟机 (JVM)</p><p><a href="https://teamwang.cn/2021/03/02/JVM/">https://teamwang.cn/2021/03/02/JVM/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jacky</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/04/SpringCloud/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spring Cloud</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/01/Concurrency%E5%B9%B6%E5%8F%91/"><span class="level-item">Java并发编程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "D7nrmJ3xSHla6mxR3p0BrXqD-gzGzoHsz",
            appKey: "rGXO6glIn8ETvzytN7maFaoP",
            placeholder: "Leave your comments~",
            
            
            meta: ["nick"],
            pageSize: 10,
            lang: "en",
            visitor: true,
            highlight: true,
            
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-JVM-结构"><span class="level-left"><span class="level-item">1. JVM 结构</span></span></a></li><li><a class="level is-mobile" href="#2-Thread-和-JVM-的关系"><span class="level-left"><span class="level-item">2. Thread 和 JVM 的关系</span></span></a></li><li><a class="level is-mobile" href="#3-JVM-的类加载器"><span class="level-left"><span class="level-item">3. JVM 的类加载器</span></span></a></li><li><a class="level is-mobile" href="#4-Images"><span class="level-left"><span class="level-item">4. Images</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-Java-堆溢出"><span class="level-left"><span class="level-item">4.1 Java 堆溢出</span></span></a></li><li><a class="level is-mobile" href="#4-2-触发-GC-的条件"><span class="level-left"><span class="level-item">4.2 触发 GC 的条件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Minor-GC"><span class="level-left"><span class="level-item">Minor GC</span></span></a></li><li><a class="level is-mobile" href="#Full-Major-GC"><span class="level-left"><span class="level-item">Full/Major GC</span></span></a></li><li><a class="level is-mobile" href="#判断对象是否“死亡”"><span class="level-left"><span class="level-item">判断对象是否“死亡”</span></span></a></li><li><a class="level is-mobile" href="#强软弱虚引用"><span class="level-left"><span class="level-item">强软弱虚引用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-四种垃圾回收算法"><span class="level-left"><span class="level-item">4.3 四种垃圾回收算法</span></span></a></li><li><a class="level is-mobile" href="#4-4-垃圾回收器"><span class="level-left"><span class="level-item">4.4 垃圾回收器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#串行回收器组合"><span class="level-left"><span class="level-item">串行回收器组合</span></span></a></li><li><a class="level is-mobile" href="#并行回收器组合"><span class="level-left"><span class="level-item">并行回收器组合</span></span></a></li><li><a class="level is-mobile" href="#并发标记清除回收器组合"><span class="level-left"><span class="level-item">并发标记清除回收器组合</span></span></a></li><li><a class="level is-mobile" href="#Garbage-First-G1"><span class="level-left"><span class="level-item">Garbage First (G1)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-5-GC-日志"><span class="level-left"><span class="level-item">4.5 GC 日志</span></span></a></li><li><a class="level is-mobile" href="#4-6-内存分配策略"><span class="level-left"><span class="level-item">4.6 内存分配策略</span></span></a></li><li><a class="level is-mobile" href="#4-7-ClassLoader-类加载器"><span class="level-left"><span class="level-item">4.7 ClassLoader 类加载器</span></span></a></li><li><a class="level is-mobile" href="#4-8-剩下的图片"><span class="level-left"><span class="level-item">4.8 剩下的图片</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-配置-amp-调优"><span class="level-left"><span class="level-item">5. 配置&amp;调优</span></span></a></li><li><a class="level is-mobile" href="#6-Java-版本"><span class="level-left"><span class="level-item">6. Java 版本</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-发布日期"><span class="level-left"><span class="level-item">6.1 发布日期</span></span></a></li><li><a class="level is-mobile" href="#6-2-JDK-9-17-功能特性"><span class="level-left"><span class="level-item">6.2 JDK 9~17 功能特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JDK9"><span class="level-left"><span class="level-item">JDK9</span></span></a></li><li><a class="level is-mobile" href="#JDK10"><span class="level-left"><span class="level-item">JDK10</span></span></a></li><li><a class="level is-mobile" href="#JDK11（LTS）"><span class="level-left"><span class="level-item">JDK11（LTS）</span></span></a></li><li><a class="level is-mobile" href="#JDK12"><span class="level-left"><span class="level-item">JDK12</span></span></a></li><li><a class="level is-mobile" href="#JDK13"><span class="level-left"><span class="level-item">JDK13</span></span></a></li><li><a class="level is-mobile" href="#JDK14"><span class="level-left"><span class="level-item">JDK14</span></span></a></li><li><a class="level is-mobile" href="#JDK15"><span class="level-left"><span class="level-item">JDK15</span></span></a></li><li><a class="level is-mobile" href="#JDK16"><span class="level-left"><span class="level-item">JDK16</span></span></a></li><li><a class="level is-mobile" href="#JDK17"><span class="level-left"><span class="level-item">JDK17</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-3-JDK版本机制"><span class="level-left"><span class="level-item">6.3 JDK版本机制</span></span></a></li><li><a class="level is-mobile" href="#6-4-Oracle免费JDK"><span class="level-left"><span class="level-item">6.4 Oracle免费JDK</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Jacky"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jacky</p><p class="is-size-6 is-block">(ง ˙o˙)ว</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/cloris-cc"><i class="fab fa-github"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span>&copy; 2021 Jacky</span>  <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备19098392号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/"><i class="fab fa-weibo"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/cloris-cc"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>