<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java基础知识 - 茶茶日记 - winklog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="茶茶日记 - winklog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="茶茶日记 - winklog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="涵盖了 Java 许多重要的基础知识～"><meta property="og:type" content="blog"><meta property="og:title" content="Java基础知识"><meta property="og:url" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="茶茶日记 - winklog"><meta property="og:description" content="涵盖了 Java 许多重要的基础知识～"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/85eb779f-52db-4f42-be0b-42d22a148857.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/84659150-7689-4892-a492-71ef66b4e58a.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/d011ab5f-e399-44bc-8899-aac30535f850.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/195a34ab-931b-4222-a1e6-27b1c744e9be.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75f3b2ff-3328-4ec1-86ae-6da5436a93fa.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/62fb2634-d98b-4268-8806-c7e6a7a94ec6.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c18dcea9-a353-48c8-8ef6-5430fb7786bf.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/b55cc696-2ba1-4632-ae47-c713fde97014.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/140fca40-e2db-4a22-b25d-c59f3ec78848.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a78b599d-52b7-48b4-8c35-f4b3c559681a.jpg"><meta property="og:image" content="https://gitee.com/jacky_cloud/oss/raw/master/uPic/1bRzLx.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7f12a453-71c2-4be4-b027-35f30f5e2488.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/138200.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/36625762-5d74-48d1-a17e-6f0927a2e02c.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/772a6297-34a2-4d5a-8ba5-8e5ed229a800.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/76eba3a4-9143-4108-a789-0c0e5efdf468.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12b4c5ee-5278-483d-95b6-d28f5fe28b9f.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1a7cbd81-1d25-49d2-9a27-e741e24b0af4.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/834b6f6b-3a66-4058-86b3-8ecfd3fb7d58.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/47c4b784-433e-4958-9869-6ae3b6586035.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19415199-1e04-4339-afe8-1e0b0c634ec9.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9a6124a1-a1af-4786-9cc3-14b1e94e2380.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/634b28bd-f0c8-4c57-b65f-ecd191bc3b21.jpg"><meta property="og:image" content="https://i.loli.net/2021/04/14/2WY8NqZJc5kUvld.png"><meta property="og:image" content="https://i.loli.net/2021/04/14/VSxY3tQWTqMpw1k.png"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c1c2dedc-be29-4e4c-a49f-84a72d0b5d23.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9ee3aa13-cd44-491c-9db7-1524b5043d89.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08735d98-7666-46b2-8956-3779a2434d88.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/e1e7d227-f2df-4721-ba26-aa64396c36f3.jpg"><meta property="og:image" content="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75b6deb9-2960-4640-afb7-3963fe14f0f1.png"><meta property="article:published_time" content="2021-02-28T15:43:08.000Z"><meta property="article:modified_time" content="2021-10-29T08:12:20.665Z"><meta property="article:author" content="Jacky"><meta property="article:tag" content="茶茶,日记,茶茶日记,winklog,WinkLog,博客,teamwang,TeamWang,王嘉尔,Jakcy,jacky"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/85eb779f-52db-4f42-be0b-42d22a148857.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},"headline":"Java基础知识","image":["https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/85eb779f-52db-4f42-be0b-42d22a148857.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/84659150-7689-4892-a492-71ef66b4e58a.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/d011ab5f-e399-44bc-8899-aac30535f850.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/195a34ab-931b-4222-a1e6-27b1c744e9be.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75f3b2ff-3328-4ec1-86ae-6da5436a93fa.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/62fb2634-d98b-4268-8806-c7e6a7a94ec6.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c18dcea9-a353-48c8-8ef6-5430fb7786bf.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/b55cc696-2ba1-4632-ae47-c713fde97014.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/140fca40-e2db-4a22-b25d-c59f3ec78848.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a78b599d-52b7-48b4-8c35-f4b3c559681a.jpg","https://gitee.com/jacky_cloud/oss/raw/master/uPic/1bRzLx.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7f12a453-71c2-4be4-b027-35f30f5e2488.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/138200.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/36625762-5d74-48d1-a17e-6f0927a2e02c.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/772a6297-34a2-4d5a-8ba5-8e5ed229a800.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/76eba3a4-9143-4108-a789-0c0e5efdf468.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12b4c5ee-5278-483d-95b6-d28f5fe28b9f.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1a7cbd81-1d25-49d2-9a27-e741e24b0af4.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/834b6f6b-3a66-4058-86b3-8ecfd3fb7d58.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/47c4b784-433e-4958-9869-6ae3b6586035.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19415199-1e04-4339-afe8-1e0b0c634ec9.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9a6124a1-a1af-4786-9cc3-14b1e94e2380.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/634b28bd-f0c8-4c57-b65f-ecd191bc3b21.jpg","https://i.loli.net/2021/04/14/2WY8NqZJc5kUvld.png","https://i.loli.net/2021/04/14/VSxY3tQWTqMpw1k.png","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c1c2dedc-be29-4e4c-a49f-84a72d0b5d23.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9ee3aa13-cd44-491c-9db7-1524b5043d89.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08735d98-7666-46b2-8956-3779a2434d88.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/e1e7d227-f2df-4721-ba26-aa64396c36f3.jpg","https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75b6deb9-2960-4640-afb7-3963fe14f0f1.png"],"datePublished":"2021-02-28T15:43:08.000Z","dateModified":"2021-10-29T08:12:20.665Z","author":{"@type":"Person","name":"Jacky"},"description":"涵盖了 Java 许多重要的基础知识～"}</script><link rel="canonical" href="https://teamwang.cn/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?05af3f3bd18ffe652b63cc7ee6abb48c";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="茶茶日记 - winklog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时光轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-28T15:43:08.000Z" title="2/28/2021, 11:43:08 PM">2021-02-28</time>发表</span><span class="level-item"><time dateTime="2021-10-29T08:12:20.665Z" title="10/29/2021, 4:12:20 PM">2021-10-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="level-item">1 小时读完 (大约11479个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java基础知识</h1><div class="content"><p>涵盖了 Java 许多重要的基础知识～</p>
<span id="more"></span>

<h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一 数据类型"></a>一 数据类型</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><ol>
<li>基本数据类型（或叫做原生类、内置类型）8种：<ul>
<li>整数：byte，short，int，long（默认是int类型）</li>
<li>浮点类型： float，double（默认是double类型）</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
</li>
</ol>
<ol start="2">
<li>引用数据类型3种：数组，类，接口</li>
</ol>
<h2 id="1-2-和-equals-的区别"><a href="#1-2-和-equals-的区别" class="headerlink" title="1.2 == 和 equals 的区别"></a>1.2 == 和 equals 的区别</h2><p>用法上的区别：== 比较(引用的)内存地址，equals 比较内容是否一样。</p>
<p>代码实现：默认的<code>Object.equals()</code>方法也是使用 == 做判断，而<code>String.equals()</code>方法比较了每个Character字符，并重写了<code>hashCode</code>方法。如果要重写<code>equals</code>方法，同时也应重写<code>hashCode</code>方法。</p>
<p>如果不重写对象的hashCode，当两者equals为true但hashCode不同，存放在双列容器Map中也会是两个不同的对象。因为Map比较key时，会先比较hashCode，再使用equals方法。</p>
<p>e.g. 使用JDK1.7<strong>BKDR哈希算法</strong>重写(即使用 Objects.equals/hash)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// omit getter and setter </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Laptop laptop = (Laptop) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, laptop.name) &amp;&amp; Objects.equals(price, laptop.price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是String的hashCode方法，也使用了BKDR Hash：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>e.g. == 判断 box，equals 判断 value</p>
<ul>
<li>new Integer(3) == new Integer(3)  不是同个box, false</li>
<li>new Integer(3) == 3 (int)  同个box, true</li>
</ul>
<h1 id="二-Thread"><a href="#二-Thread" class="headerlink" title="二 Thread"></a>二 Thread</h1><h2 id="2-1-线程安全与数据同步"><a href="#2-1-线程安全与数据同步" class="headerlink" title="2.1 线程安全与数据同步"></a>2.1 线程安全与数据同步</h2><ul>
<li>synchronized：包括monitor enter和monitor exit两个JVM指令。保证执行enter/exit都能读写主内存数据。<ul>
<li>monitor：每一个对象与一个monitor关联，enter时monitor计数器+1,exit时monitor计数器-1。</li>
</ul>
</li>
<li>HashMap不是线程安全的，多线程同时写操作容易出现死循环引起死锁。</li>
</ul>
<h2 id="2-2-锁"><a href="#2-2-锁" class="headerlink" title="2.2 锁"></a>2.2 锁</h2><h3 id="2-2-1-悲观锁-amp-乐观锁"><a href="#2-2-1-悲观锁-amp-乐观锁" class="headerlink" title="2.2.1 悲观锁 &amp; 乐观锁"></a>2.2.1 悲观锁 &amp; 乐观锁</h3><h4 id="a-悲观锁"><a href="#a-悲观锁" class="headerlink" title="a. 悲观锁"></a>a. 悲观锁</h4><ul>
<li><p>每次取数据的时候都会先加锁，Synchronized是悲观锁。</p>
</li>
<li><p>传统关系型数据库的行锁、表锁和读写锁等也是悲观锁，都是在操作之前先上锁。</p>
</li>
<li><p>存在的问题：</p>
<ul>
<li><p>在多线程竞争下，加锁、释放锁会导致比较多的<strong>线程上下文切换</strong>和<strong>调度延时</strong>，引起性能问题。</p>
</li>
<li><p>一个线程持有锁会导致其它所有需要此锁的线程挂起 (线程阻塞)。</p>
</li>
<li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
</li>
</ul>
</li>
</ul>
<h4 id="b-乐观锁"><a href="#b-乐观锁" class="headerlink" title="b. 乐观锁"></a>b. 乐观锁</h4><ul>
<li><p>很乐观，每次拿数据的是都认为别人不会来修改，所以不上锁。</p>
</li>
<li><p>在更新的时候会判断一下在此别人有没有也来更新这个数据，可以使用<mark>版本号</mark>等机制。由于使用了版本号机制，所以 CAS 原理不会产生 ABA 问题。</p>
</li>
<li><p>乐观锁适合read的场景，可以提高tps，类似于数据库write_condition机制</p>
</li>
<li><p>CAS<Compare And Swap>是其中一种实现方式。JUC就是建立在CAS上的。(the entities have ‘Lock’, ‘ReadWriteLock’)</p>
</li>
</ul>
<h3 id="2-2-2-Synchronized-和-Lock"><a href="#2-2-2-Synchronized-和-Lock" class="headerlink" title="2.2.2 Synchronized 和 Lock"></a>2.2.2 Synchronized 和 Lock</h3><h4 id="2-2-2-1-特性"><a href="#2-2-2-1-特性" class="headerlink" title="2.2.2.1 特性"></a>2.2.2.1 特性</h4><blockquote>
<p>以下一个锁是原生语义上的实现</p>
</blockquote>
<ul>
<li>  Synchronized，它就是一个：非公平，悲观，独享，互斥，可重入的重量级锁</li>
</ul>
<p>可重入锁：可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</p>
<blockquote>
<p>以下两个锁都在JUC包下，是API层面上的实现</p>
</blockquote>
<ul>
<li>  ReentrantLock，它是一个：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁。</li>
<li>  ReentrantReadWriteLocK，它是一个，默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁。</li>
</ul>
<blockquote>
<p>Lock接口源码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(Long time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-2-1-区别"><a href="#2-2-2-1-区别" class="headerlink" title="2.2.2.1 区别"></a>2.2.2.1 区别</h4><p>对于<code>ReentrantLock</code>，有以下特性：</p>
<ol>
<li><p>等待可中断。</p>
<blockquote>
<p>等待可中断是指<strong>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</strong>，可中断特性对处理执行时间非常长的同步块很有帮助。</p>
</blockquote>
</li>
<li><p>可实现公平锁</p>
<blockquote>
<p>公平锁是指<strong>多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</strong>；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<br>synchronized中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p>
</blockquote>
</li>
<li><p>锁可以绑定多个条件</p>
<blockquote>
<p>锁绑定多个条件是指<strong>一个 ReentrantLock 对象可以同时绑定多个 Condition 对象</strong>，而在synchronized中，锁对象的 wait（）和 notify（）或 notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition（）方法即可。</p>
</blockquote>
</li>
</ol>
<p>用法上的不同：</p>
<ol>
<li><p>synchronized 是在JVM层面上实现的，<strong>不但可以通过一些监控工具监控synchronized 的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用 Lock 则不行</strong>，lock 是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock() 放到 finally{} 中。</p>
</li>
<li><p>在资源竞争不是很激烈的情况下，Synchronized 的性能要优于 ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized 的性能会下降几十倍，但是 ReetrantLock 的性能能维持常态；</p>
</li>
</ol>
<h3 id="2-2-3-自旋锁-自适应自旋锁"><a href="#2-2-3-自旋锁-自适应自旋锁" class="headerlink" title="2.2.3 自旋锁/自适应自旋锁"></a>2.2.3 自旋锁/自适应自旋锁</h3><p>自旋锁：</p>
<blockquote>
<p>在Java中，<strong>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。<br><strong>自旋次数的默认值是10次</strong>，若仍然没有成功获得锁，则使用传统的方式挂起线程。</p>
</blockquote>
<p>自适应自旋锁：</p>
<blockquote>
<p>在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前 一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
</blockquote>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长时间，比如100个循环。</li>
<li>如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源.</li>
</ul>
<h3 id="2-2-4-锁的状态：偏向锁-轻量级锁-重量级锁"><a href="#2-2-4-锁的状态：偏向锁-轻量级锁-重量级锁" class="headerlink" title="2.2.4 锁的状态：偏向锁/轻量级锁/重量级锁"></a>2.2.4 锁的状态：偏向锁/轻量级锁/重量级锁</h3><p>偏向锁：</p>
<blockquote>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
</blockquote>
<p>轻量级锁(自旋)：</p>
<blockquote>
<p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
</blockquote>
<p>重量级锁(阻塞)：</p>
<blockquote>
<p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
</blockquote>
<h3 id="2-2-5-分段锁-ConcurrentHashMap"><a href="#2-2-5-分段锁-ConcurrentHashMap" class="headerlink" title="2.2.5 分段锁 - ConcurrentHashMap"></a>2.2.5 分段锁 - ConcurrentHashMap</h3><p>ConcurrentHashMap中的分段锁称为<strong>Segment</strong>，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即**内部拥有一个Entry数组。数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment 继承了 ReentrantLock)**。</p>
<p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过 <strong>hashcode</strong> 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>
<p>但是，在统计size的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h2 id="2-3-线程的五种状态"><a href="#2-3-线程的五种状态" class="headerlink" title="2.3 线程的五种状态"></a>2.3 线程的五种状态</h2><ul>
<li>新建、可运行、运行、阻塞、死亡</li>
</ul>
<h2 id="2-4-线程间通信"><a href="#2-4-线程间通信" class="headerlink" title="2.4 线程间通信"></a>2.4 线程间通信</h2><h3 id="2-4-1-同步阻塞和异步非阻塞消息处理的区别"><a href="#2-4-1-同步阻塞和异步非阻塞消息处理的区别" class="headerlink" title="2.4.1 同步阻塞和异步非阻塞消息处理的区别"></a>2.4.1 同步阻塞和异步非阻塞消息处理的区别</h3><ul>
<li><p>同步阻塞消息处理的过程：每次提交一个event，服务端接受event创建线程处理，返回结果。</p>
</li>
<li><p>异步非阻塞消息处理的过程：提交even，放入event<strong>队列</strong>(立即返回工单)，让<strong>多个线程</strong>(线程数量在可控范围之内)处理。</p>
<ul>
<li>降低CPU上下文切换线程的开销；</li>
<li>线程可以重复利用，减少创建线程的资源浪费；</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-wait-and-notify-methods"><a href="#2-4-2-wait-and-notify-methods" class="headerlink" title="2.4.2 wait() and notify() methods"></a>2.4.2 wait() and notify() methods</h3><ul>
<li>wait()方法必须必须拥有该对象的monitor，不然肿么让锁，即wait方法必须在<strong>同步方法块</strong>中使用；notify方法也一样。</li>
<li>哪个对象wait，哪个对象就notify。否则抛出IllegalMonitorStateException异常。</li>
</ul>
<h3 id="2-4-3-sleep-和-wait-方法的比较"><a href="#2-4-3-sleep-和-wait-方法的比较" class="headerlink" title="2.4.3 sleep 和 wait 方法的比较"></a>2.4.3 sleep 和 wait 方法的比较</h3><ul>
<li>相同点：<ul>
<li>都可以使线程进入阻塞状态</li>
<li>均是可中断方法，被中断后都会收到中断异常</li>
</ul>
</li>
<li>不同点：<ul>
<li>wait时Object的方法，sleep时Thread特有的方法。(Thread也是Object)</li>
<li>wait方法&lt;让锁&gt;必须在同步代码块中执行，sleep不需要。</li>
<li>sleep方法短暂休眠之后会主动退出阻塞，而wait(没有指定 wait 时间)则需要被其他线程中断后才能退出阻塞。</li>
</ul>
</li>
</ul>
<h2 id="2-5-多线程间通信"><a href="#2-5-多线程间通信" class="headerlink" title="2.5 多线程间通信"></a>2.5 多线程间通信</h2><h3 id="2-5-1-注意"><a href="#2-5-1-注意" class="headerlink" title="2.5.1 注意"></a>2.5.1 注意</h3><ul>
<li>If 条件语句在多线程情况下不可信。 change to while</li>
</ul>
<h3 id="2-5-2-Synchronized-隐式锁-关键字的缺陷"><a href="#2-5-2-Synchronized-隐式锁-关键字的缺陷" class="headerlink" title="2.5.2 Synchronized (隐式锁)关键字的缺陷"></a>2.5.2 Synchronized (隐式锁)关键字的缺陷</h3><ul>
<li>无法控制阻塞时长，且阻塞不可中断。(某个线程在获取monitor lock的时候可能被阻塞)</li>
</ul>
<h2 id="2-6-类加载的过程"><a href="#2-6-类加载的过程" class="headerlink" title="2.6 类加载的过程"></a>2.6 类加载的过程</h2><h3 id="2-6-1-过程简介"><a href="#2-6-1-过程简介" class="headerlink" title="2.6.1 过程简介"></a>2.6.1 过程简介</h3><ul>
<li>加载阶段、连接阶段（验证 准备 解析）、初始化阶段</li>
</ul>
<h3 id="2-6-2-类的主动使用和被动使用"><a href="#2-6-2-类的主动使用和被动使用" class="headerlink" title="2.6.2 类的主动使用和被动使用"></a>2.6.2 类的主动使用和被动使用</h3><p>被动使用不会导致类的加载和<strong>初始化</strong>。另外，初始化只会执行静态代码(在Metaspace)，而实例化包括初始化外，还会运行构造方法、分配空间(Head)等操作。</p>
<ul>
<li>主动使用的场景：new、访问类的静态变量或静态方法、<strong>反射操作</strong>&lt;Class.forName()&gt;、初始化子类、启动类(maybe反射)。</li>
<li>被动使用的场景：new某个类的数组、引用类的**静态常量(static final)**。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The GlobalConstants will be initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100</span>; <span class="comment">// 调用MAX不会初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RANDOM = <span class="keyword">new</span> Random().nextInt(); <span class="comment">// 由于计算复杂，调用此处会导致初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-类的加载过程详解"><a href="#2-6-3-类的加载过程详解" class="headerlink" title="2.6.3 类的加载过程详解"></a>2.6.3 类的加载过程详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">// ②</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton.x); <span class="comment">// 1--②放到①--0</span></span><br><span class="line">        System.out.println(singleton.y); <span class="comment">// 1--②放到①--1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-线程上下文类加载器"><a href="#2-7-线程上下文类加载器" class="headerlink" title="2.7 线程上下文类加载器"></a>2.7 线程上下文类加载器</h2><pre><code>作用：让根加载器委托子类加载器去加载厂商提供的SPI具体实现。
</code></pre>
<h2 id="2-8-深入理解-volatile-关键字"><a href="#2-8-深入理解-volatile-关键字" class="headerlink" title="2.8 深入理解 volatile 关键字"></a>2.8 深入理解 volatile 关键字</h2><h3 id="2-8-1-初始-volatile-关键字"><a href="#2-8-1-初始-volatile-关键字" class="headerlink" title="2.8.1 初始 volatile 关键字"></a>2.8.1 初始 volatile 关键字</h3><pre><code>volatile 只能修饰**实例变量**和**类变量**。
</code></pre>
<ul>
<li>实例变量：init_value 去掉 static 就是普通的实例变量。</li>
<li>类变量 (静态变量)：加 static .</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFoo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> init_value = <span class="number">0</span>; <span class="comment">// 尝试不加 volatile 的输出结果</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Reader 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = init_value;</span><br><span class="line">            <span class="keyword">while</span> (localValue &lt; MAX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (init_value != localValue) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;The init_value is updated to [%d]\n&quot;</span>, init_value);</span><br><span class="line">                    <span class="comment">// 对 localValue 进行重新赋值</span></span><br><span class="line">                    localValue = init_value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Reader&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Update 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = init_value;</span><br><span class="line">            <span class="keyword">while</span> (localValue &lt; MAX) &#123;</span><br><span class="line">                <span class="comment">// 修改 init_value</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;The init_value will be changed to [%d]\n&quot;</span>, ++localValue);</span><br><span class="line">                init_value = localValue;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 短暂休眠，使 Reader 线程有机会执行。</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Update&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CPU Cache 模型 和 Java 内存模型<JMM> 的结构类似：<ul>
<li>a. 读取操作，不做任何处理，只是将 Cache 中的数据读取到寄存器中。</li>
<li>b. 写入操作，发出信号通知其他 CPU 将该变量的 Cache line 置为无效状态，其他 CPU 在进行该变量读取的时候必须到<strong>主内存</strong>中再次获取，即再 copy 一份副本。</li>
</ul>
</li>
</ul>
<h3 id="2-8-2-并发编程的三个重要特性"><a href="#2-8-2-并发编程的三个重要特性" class="headerlink" title="2.8.2 并发编程的三个重要特性"></a>2.8.2 并发编程的三个重要特性</h3><pre><code>**原子性、有序性、可见性。**
</code></pre>
<p>原子性：一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。<br>有序性：为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，<strong>重排序</strong>可能会导致多线程程序出现内存<strong>可见性</strong>问题。<br>可见性：多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。</p>
<ul>
<li>volatile 和 synchronized 的区别：<ul>
<li>volatile 修饰实例变量和类(静态)变量；synchronized 修饰方法和代码块。</li>
<li>volatile 不能保证<strong>原子性</strong>。</li>
<li>可见性的保证：volatile 使用机器指令(偏硬件) “<strong>lock;</strong>“ 的方式迫使其他线程的工作内存中的数据失效，必须到主内存中进行再次加载。synchronized 使用 JVM 指令 <strong>monitor</strong> enter 和 monitor exit 串行化代码，在 monitor exit 时所有的共享资源都会被刷新到主内存中。</li>
<li>volatile 不会使线程进入<strong>阻塞</strong>状态，synchronized 则不同。</li>
</ul>
</li>
</ul>
<h3 id="2-8-3-volatile的使用场景"><a href="#2-8-3-volatile的使用场景" class="headerlink" title="2.8.3 volatile的使用场景"></a>2.8.3 volatile的使用场景</h3><h4 id="1-开关控制"><a href="#1-开关控制" class="headerlink" title="1) 开关控制"></a>1) 开关控制</h4><h4 id="2-状态标记"><a href="#2-状态标记" class="headerlink" title="2) 状态标记"></a>2) 状态标记</h4><h4 id="3-Singleton-的-double-check"><a href="#3-Singleton-的-double-check" class="headerlink" title="3) Singleton 的 double-check"></a>3) Singleton 的 double-check</h4><h3 id="2-8-4-7种单例模式的设计"><a href="#2-8-4-7种单例模式的设计" class="headerlink" title="2.8.4 7种单例模式的设计"></a>2.8.4 7种单例模式的设计</h3><pre><code>比较方法：线程安全、高性能、懒加载。
</code></pre>
<h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1) 饿汉式"></a>1) 饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：可以保证多线程下的唯一实例，getInstance 方法性能比较高，但是无法进行懒加载。</span></span><br><span class="line"><span class="comment">* 使用场景：占用内存资源少，因为Instance被CL加载后很长一段时间才使用的话，会在堆内存驻留很长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// final 不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 在定义实例对象的时候直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有构造函数，不允许外部 new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2) 懒汉式"></a>2) 懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点： 使用实例的时候再创建(即懒加载)，无法保证多线程下的唯一实例。</span></span><br><span class="line"><span class="comment">* 使用场景：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//final 不允许被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 定义实例，但是不直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有构造函数，不允许外部 new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// 可能会有两个(或以上)线程同时看到 instance == null</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-懒汉式-同步方法"><a href="#3-懒汉式-同步方法" class="headerlink" title="3) 懒汉式 + 同步方法"></a>3) 懒汉式 + 同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 getInstance 方法加入 synchronized 同步控制，每次只有一个线程能进入。</span></span><br><span class="line"><span class="comment">// 特点：因synchronized，getInstance 方法只能被一个线程访问，性能低下。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Double-Check"><a href="#4-Double-Check" class="headerlink" title="4) Double-Check"></a>4) Double-Check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：懒加载 + 保证多线程下的唯一实例 + 提高效率，可能造成空指针异常。</span></span><br><span class="line"><span class="comment">* 空指针异常的分析：线程1创建instance实例完后，conn,socket 的实例可能尚未创建完成（由JVM发生指令重排</span></span><br><span class="line"><span class="comment">* 导致），在此期间，线程2拿到instance实例不幸使用实例变量conn或者socket，则会产生空指针异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    Connection conn;</span><br><span class="line">    Socket socket;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// 减少排队进入同步代码块的线程数量(减少阻塞)，提高效率。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// 防止下一个获得 monitor 锁的线程进入执行。add: // 可能出现：线程 1 还没初始化结束，线程 2 就直接返回 instance 了。从而导致空指针异常。</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-Volatile-Double-Check"><a href="#5-Volatile-Double-Check" class="headerlink" title="5) Volatile + Double-Check"></a>5) Volatile + Double-Check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 volatile 禁止 JVM 的指令重排。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h4 id="6-Holder-方式"><a href="#6-Holder-方式" class="headerlink" title="6) Holder 方式"></a>6) Holder 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：Singleton 初始化过程中不会创建 Instance 实例，只有当 Holder 被主动引用的时候才创建。</span></span><br><span class="line"><span class="comment">* Holder 方式的单例设计是最好的设计之一，也是目前使用比较广的设计之一。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在静态内部类中持有 Singleton 的实例，并且可被直接初始化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用 getInstance 方法，事实上时获得 Holder 的 instance 静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-枚举方式"><a href="#7-枚举方式" class="headerlink" title="7) 枚举方式"></a>7) 枚举方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点：枚举类型不允许被继承，同样是线程安全的且只能被实例化一次，但是不能懒加载。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    EnumSingleton() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INSTANCE will be initialized immediately.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用该方法则会主动使用 Singleton，INSTANCE 将会被实例化。</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 特点可实现懒加载</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用枚举充当 holder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumHolder</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton instance;</span><br><span class="line"> </span><br><span class="line">        EnumHolder() &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getEnumSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getEnumSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-9-多线程设计架构模式"><a href="#2-9-多线程设计架构模式" class="headerlink" title="2.9 多线程设计架构模式"></a>2.9 多线程设计架构模式</h2><h1 id="三-集合类"><a href="#三-集合类" class="headerlink" title="三 集合类"></a>三 集合类</h1><h2 id="3-1-Map-双列集合"><a href="#3-1-Map-双列集合" class="headerlink" title="3.1 Map (双列集合)"></a>3.1 Map (双列集合)</h2><table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Supper</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HashTable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>锁分段技术(JDK8:CAS)</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td><strong>允许为 null</strong></td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td><strong>允许为 null</strong></td>
<td><strong>允许为 null</strong></td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3><p>当容量达到75%时(默认负载因子是0.75)，自动扩容，扩容是为原来的2倍。<br>默认大小为16(1&lt;&lt;4)。<br>在确定存放元素位置的时候，使用(n-1)&amp;hash来确定存放位置。因为位与运算符&amp;在操作系统中效率很高，同时，n为2的n次幂时，和hash值计算出的结果分布更加均匀，可以减少hash冲突。<br>ArrayList扩容为原来的1.5倍。</p>
<h2 id="3-2-Collection-单列集合"><a href="#3-2-Collection-单列集合" class="headerlink" title="3.2 Collection (单列集合)"></a>3.2 Collection (单列集合)</h2><h3 id="a-List-有序"><a href="#a-List-有序" class="headerlink" title="a. List (有序)"></a>a. List (有序)</h3><table>
<thead>
<tr>
<th>-</th>
<th>性能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Vector</td>
<td>查询快，增删慢，效率低</td>
<td>线程安全</td>
</tr>
<tr>
<td>ArrayList</td>
<td>查询快，增删慢，效率高</td>
<td>线程不安全</td>
</tr>
<tr>
<td>LinkedList</td>
<td>查询慢，增删快，效率高</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<pre><code>**线程安全**的List/Set:`CopyOnWriteArrayList`,实现原理如下：
</code></pre>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/85eb779f-52db-4f42-be0b-42d22a148857.jpg"></p>
<p><strong>写操作在copy且加锁的副本上(串行)，读操作则在原容器读(并行)。</strong></p>
<p><strong>优点:</strong></p>
<p>1.解决的开发工作中的多线程的并发问题。</p>
<p><strong>缺点:</strong></p>
<p>**1.内存占有问题:**很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。</p>
<p>**2.数据一致性:**CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器</p>
<h3 id="b-Set-有序"><a href="#b-Set-有序" class="headerlink" title="b. Set (有序)"></a>b. Set (有序)</h3><table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TreeSet</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="四-零散知识"><a href="#四-零散知识" class="headerlink" title="四 零散知识"></a>四 零散知识</h1><ul>
<li><p><code>String.trim()</code>: remove the space of head and end.</p>
</li>
<li><p><code>String.split(&quot; &quot;)</code>: split the space and construct Stirng Arrays.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(in.nextLine().trim()); <span class="comment">// input a number in line and trim the space of head and end.</span></span><br><span class="line">String[] strArr = in.nextLine.trim().split(<span class="string">&quot; &quot;</span>); <span class="comment">// input &quot; hello world  &quot;.</span></span><br><span class="line">System.out.println(strArr); <span class="comment">// ouput [hello, world].</span></span><br></pre></td></tr></table></figure></li>
<li><p>Context 是 MetaData 的具体表现。</p>
</li>
</ul>
<h2 id="1-java-关键字总结"><a href="#1-java-关键字总结" class="headerlink" title="1. java 关键字总结"></a>1. java 关键字总结</h2><h3 id="1-1-final-关键字"><a href="#1-1-final-关键字" class="headerlink" title="1.1 final 关键字"></a>1.1 final 关键字</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<p>修饰类/方法时，表明这个类/方法不能被<strong>继承</strong>。final 类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>private 方法也隐式地指定为 final。</p>
<p>final 不能修饰<strong>接口、抽象类</strong>；final修饰的方法不能继承但可以被<strong>重载</strong>；</p>
<p>final 修饰的变量不一定都是<strong>常量</strong>！final 修饰对象，如 map (引用数据类型)时，仅代表不能指向其它对象，但是 map 的值还是能够被改变的，这就会产生线程安全问题。只有当 final 修饰基本数据类型的变量时，才是常量。</p>
<h3 id="1-2-static-关键字"><a href="#1-2-static-关键字" class="headerlink" title="1.2 static 关键字"></a>1.2 static 关键字</h3><p>修饰变量、方法、代码块、静态内部类、静态导包。</p>
<p>修饰变量或方法：静态变量存放在JVM的方法区/永久代/meta space。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></p>
<p>修饰类时，由于没有内部引用(指针)，故不能使用任何<strong>外围类</strong>的非static变量和方法。对自己更严格。</p>
<h3 id="1-3-this-关键字"><a href="#1-3-this-关键字" class="headerlink" title="1.3 this 关键字"></a>1.3 this 关键字</h3><p>引用类的当前实例。</p>
<h3 id="1-4-super-关键字"><a href="#1-4-super-关键字" class="headerlink" title="1.4 super 关键字"></a>1.4 super 关键字</h3><p>父类的引用。</p>
<h3 id="1-5-attention"><a href="#1-5-attention" class="headerlink" title="1.5 attention"></a>1.5 attention</h3><p>this 和 super 必须放在<strong>首行</strong>，不能用在 static 方法中。</p>
<h2 id="2-抽象类和接口的区别"><a href="#2-抽象类和接口的区别" class="headerlink" title="2. 抽象类和接口的区别"></a>2. 抽象类和接口的区别</h2><ul>
<li>方法、继承两方面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以实现多个接口，但是 java 不能实现多继承。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口也可以有实例变量。</span></span><br><span class="line">    String description = <span class="string">&quot;Unknow Beverage&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象类的方法必须实现，抽象方法不能实现(在子类中实现)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h2 id="3-Override-和-Overload-的区别"><a href="#3-Override-和-Overload-的区别" class="headerlink" title="3. Override 和 Overload 的区别"></a>3. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dazuihou/p/3569558.html">Override 和 Overload 的区别</a></h2><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/84659150-7689-4892-a492-71ef66b4e58a.png"></p>
<h2 id="4-封装、继承和多态"><a href="#4-封装、继承和多态" class="headerlink" title="4. 封装、继承和多态"></a>4. 封装、继承和多态</h2><h3 id="多态的描述"><a href="#多态的描述" class="headerlink" title="多态的描述"></a>多态的描述</h3><ul>
<li>编译时多态：方法重载，即 Overload.</li>
<li>运行时多态：继承是基础。</li>
</ul>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5. 泛型"></a>5. 泛型</h2><p>语法：</p>
<ul>
<li>类：class ArrayList<T> {…}</li>
<li>方法：public <strong><T></strong> void printList(<strong>List<T></strong> data) {…}</li>
<li>调用static方法：LinkedList.<Integer>newEmptyList();</li>
</ul>
<p>运行时如何知道泛型的类型？</p>
<p>将类型作为参数传递,如：<code>void &lt;T&gt; printList(List&lt;T&gt; data, class&lt;T&gt; elementType)</code></p>
<h2 id="6-值传递-amp-引用传递"><a href="#6-值传递-amp-引用传递" class="headerlink" title="6. 值传递 &amp; 引用传递"></a>6. 值传递 &amp; 引用传递</h2><p>值传递：copy了值，实际上是2份数据。e.g. 基本数据类型。</p>
<p>引用传递：只传递引用的地址，实际上是1份数据。e.g. 引用数据类型(数组，类，接口)</p>
<h1 id="MySQL相关"><a href="#MySQL相关" class="headerlink" title="MySQL相关"></a>MySQL相关</h1><h2 id="三范式-amp-四特性"><a href="#三范式-amp-四特性" class="headerlink" title="三范式&amp;四特性"></a>三范式&amp;四特性</h2><blockquote>
<p>summery: 主键(唯一)、字段(不可再分)、主键+字段(无冗余，和主键直接相关)</p>
</blockquote>
<ol>
<li>第一范式：每个字段都不可再分(原子性)</li>
<li>第二范式：确保表中的每列都和主键相关<img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/d011ab5f-e399-44bc-8899-aac30535f850.png"></li>
<li>第三范式：确保每列都和主键列直接相关,而不是间接相关。<img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/195a34ab-931b-4222-a1e6-27b1c744e9be.png"></li>
</ol>
<p>四特性：ACIO</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>事务隔离级别：</p>
</blockquote>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75f3b2ff-3328-4ec1-86ae-6da5436a93fa.png"></p>
<blockquote>
<p>并发事务带来的问题：</p>
</blockquote>
<p>脏读：读取了被修改过但是<strong>未提交到数据库</strong>的数据。</p>
<p>不可重复读：<strong>一个事务多次</strong>读取同一数据但是结果不一样(数据被<strong>修改</strong>)。</p>
<p>幻读：同上，但是数据<strong>增加或删除</strong>了。</p>
<blockquote>
<p>默认隔离级别(Repeatable Read)如何避免幻读？</p>
</blockquote>
<p>两种情况：</p>
<ol>
<li>快照读(无锁,如 select)：通过 <strong>MVCC</strong>(多版本控制)</li>
<li>当前读(有锁，如 select…for update/lock in share mode和修改操作，即update , delete , insert)：通过<strong>行锁+gap锁</strong>（mysql官方文档称为 <strong>Next-Key Locks</strong>）</li>
</ol>
<p>例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p>
<p><strong>MVCC多版本控制</strong></p>
<p>实现：DB_REX_ID, DB_ROLL_PTR(undo log?), DB_ROW_ID</p>
<p><strong>gap锁的介绍</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>举个栗子，我们在一个事务中执行上述的SQL语句,数据库中只有age=1，age=4，age=7，age=8 这三条满足条件的记录,那么gap锁会加到age=2，3，5，6，9上面，如果另外一个事务里面想insert age=2，3，5，6，9 是会被阻塞的，因为第一个事务拿到了gap锁。</p>
<p>gap锁会用在<strong>普通索引</strong>或<strong>无索引</strong>的当前读中。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>避免全表扫描，提高查找速度。</p>
</blockquote>
<h3 id="索引的种类："><a href="#索引的种类：" class="headerlink" title="索引的种类："></a>索引的种类：</h3><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/62fb2634-d98b-4268-8806-c7e6a7a94ec6.png"></p>
<h3 id="索引使用的数据结构："><a href="#索引使用的数据结构：" class="headerlink" title="索引使用的数据结构："></a>索引使用的数据结构：</h3><h4 id="树索引"><a href="#树索引" class="headerlink" title="树索引"></a>树索引</h4><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c18dcea9-a353-48c8-8ef6-5430fb7786bf.jpg"></p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/b55cc696-2ba1-4632-ae47-c713fde97014.jpg"></p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/140fca40-e2db-4a22-b25d-c59f3ec78848.jpg"></p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a78b599d-52b7-48b4-8c35-f4b3c559681a.jpg"></p>
<p>B-Tree因为一个节点有多个孩子，所以相对于二叉树深度k阶降低，减少了系统的<strong>IO次数</strong>。</p>
<p>B+树和B树的区别：非叶子节点仅用做索引，将数据都存放在了叶子节点上且数据有序。同时B+树上的叶子结点增加了<strong>顺序访问指针</strong>，所以同级/范围内的(叶子节点)数据能够互相访问，<strong>不需要再回到父节点</strong>查找数据，<strong>减少了磁盘IO</strong>次数。</p>
<ol>
<li>磁盘读写代价更低 2. 查询效率更稳定O(<strong>logN</strong>,哈希索引最好为O(1)) 3. 有利于对数据库的扫描</li>
</ol>
<h4 id="Hash索引的缺点"><a href="#Hash索引的缺点" class="headerlink" title="Hash索引的缺点"></a>Hash索引的缺点</h4><ol>
<li>仅能满足=、in，不能使用范围查询</li>
<li>无法使用<strong>部分索引</strong></li>
<li>不能避免全表扫描</li>
<li>哈希冲突时，性能低下。</li>
</ol>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>从左向右匹配(组合索引)直到有范围查询(&gt;,&lt;,between,like)就停止。<br>如对组合索引（a,b,c,d）来说，where a = 3 and b = 4 and c &lt; 5 and d = 6 中d是用不到索引的，所以不会使用该组合索引。但如果组合索引为（a,b,d,c）则都可以用到。<br>=可以乱序，mysql会自动识别。</p>
<p><img src="https://gitee.com/jacky_cloud/oss/raw/master/uPic/1bRzLx.png" alt="1bRzLx"></p>
<h2 id="优化查询速度"><a href="#优化查询速度" class="headerlink" title="优化查询速度"></a>优化查询速度</h2><blockquote>
<p>可能需要通过工具如Druid查询原因.</p>
<p>tips: join小表驱动大表</p>
</blockquote>
<ol start="0">
<li>索引</li>
<li>限定查询数据范围</li>
<li>读写分离(Replications)</li>
<li>垂直/水平分区（事务复杂）</li>
<li>数据库分片</li>
</ol>
<p>query commands: <code>show variables like &#39;%query%&#39;;</code> &amp; <code>explain ..;</code>（其实用druid更方便吧…）<br>set commands: <code>set global slow_query_log=on;</code> &amp; <code>set global long_query_time=1</code> (用命令改的参数在mysql重启后会失效，推荐的方式是在my.ini/my.cnf配置文件中修改)</p>
<p>其中慢sql相关变量为 long_query_time=10(s) / slow_query_log=OFF / slow_query_log_file=…</p>
<p>当设置开启慢查询记录功能后，<strong>慢sql</strong>将会被记录在日志中。</p>
<p><strong>explain 示例</strong></p>
<table>
<thead>
<tr>
<th>all</th>
<th>index</th>
<th>range</th>
<th>ref</th>
<th>ref_eq</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>全表扫描</td>
<td>有顺序的全表扫描</td>
<td>索引范围扫描</td>
<td>使用索引，索引值不唯一</td>
<td>唯一索引查找</td>
<td>以主键为查询条件</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> m.<span class="operator">*</span> <span class="keyword">from</span> base_mobile_menu m</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> base_mobile_authority a</span><br><span class="line">        <span class="keyword">on</span> m.id <span class="operator">=</span> a.menu_id</span><br><span class="line">        <span class="keyword">and</span> a.role_id <span class="operator">=</span> &quot;d0278641a3d04e64987c2fbec1e778da&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7f12a453-71c2-4be4-b027-35f30f5e2488.png"></p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/138200.png"></p>
<h2 id="部分语法"><a href="#部分语法" class="headerlink" title="部分语法"></a>部分语法</h2><p>group by(分组) / having(一般用做对分组结果进行筛选，也可以像where一样使用) / 统计相关: count, sum, max, min, avg</p>
<p>同个sql中的顺序： where… group by… having(with func)</p>
<h2 id="InnoDB-和-MyISAM-区别"><a href="#InnoDB-和-MyISAM-区别" class="headerlink" title="InnoDB 和 MyISAM 区别"></a>InnoDB 和 MyISAM 区别</h2><h4 id="锁的区别"><a href="#锁的区别" class="headerlink" title="锁的区别"></a>锁的区别</h4><p>MyISAM查询的时候会做<strong>全表锁</strong>(排它锁)，此时无法执行更新等操作（即<strong>查询&amp;修改</strong>操作不能同时执行，但是可以同时执行多个读操作）。相对于支持事务的InnoDB引擎查询速度更快。</p>
<p>InnoDB select默认不加锁，修改操作默认使用<strong>行级锁</strong>。而读操作也可以通过在select语句后加<code>for update</code>实现行锁。</p>
<p>InnoDB 在select时若不走索引，会默认使用<strong>全表锁</strong>。</p>
<p>此外，表锁不会出现死锁的情况。因为该表的资源锁只能同时给一个线程占有。</p>
<h4 id="MyISAM适用场景"><a href="#MyISAM适用场景" class="headerlink" title="MyISAM适用场景"></a>MyISAM适用场景</h4><p>count语句 + 更新不高，查询频繁 + 没有事务 （似乎适合用做读写分离的slave从库）</p>
<h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>?serverTimezone=GMT%2B8</p>
<h3 id="修改最大连接数"><a href="#修改最大连接数" class="headerlink" title="修改最大连接数"></a>修改最大连接数</h3><p>通常，mysql的最大连接数默认是100, 最大可以达到16384。<br>1、查看最大连接数:<br>show variables like ‘%max_connections%’;<br>2、修改最大连接数</p>
<p>方法一：修改配置文件。推荐方法一。<br>进入MySQL安装目录 打开MySQL配置文件 my.ini 或 my.cnf查找 max_connections=100 修改为 max_connections=1000 服务里重起MySQL即可.</p>
<p>方法二：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%91%BD%E4%BB%A4%E8%A1%8C&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">命令行</a>修改。不推荐方法二。<br>命令行登录MySQL后。设置新的MySQL最大连接数为200：<br>MySQL&gt; set global max_connections=200。<br>这种方式有个问题，就是设置的最大连接数只在mysql当前服务进程有效，一旦mysql重启，又会恢复到初始状态。因为mysql启动后的<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>工作是从其配置文件中读取数据的，而这种方式没有对其配置文件做更改。</p>
<h3 id="8-小时连接自动失效"><a href="#8-小时连接自动失效" class="headerlink" title="8 小时连接自动失效"></a>8 小时连接自动失效</h3><p>查看失效时间：<code>show variables like &#39;wait_timeout&#39;;</code><br>设置失效时间：<code>set global wait_timeout=xxx;</code><br>一般情况下，应检查代码配置。</p>
<h3 id="为什么要用自增id做主键"><a href="#为什么要用自增id做主键" class="headerlink" title="为什么要用自增id做主键"></a>为什么要用自增id做主键</h3><blockquote>
<p>这里不包括分布式的场景，因为不能保证主键的唯一性。</p>
</blockquote>
<pre><code>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。
</code></pre>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/36625762-5d74-48d1-a17e-6f0927a2e02c.png"></p>
<h3 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h3><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/772a6297-34a2-4d5a-8ba5-8e5ed229a800.jpg"><br><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/76eba3a4-9143-4108-a789-0c0e5efdf468.png"></p>
<h1 id="Redis-相关"><a href="#Redis-相关" class="headerlink" title="Redis 相关"></a>Redis 相关</h1><h2 id="5-种数据结构"><a href="#5-种数据结构" class="headerlink" title="5 种数据结构"></a>5 种数据结构</h2><blockquote>
<p>三种 list</p>
</blockquote>
<p>string、list、hash、set 和 zset(SortedSet)</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><pre><code>**LRU**（Least recently used，最近最少使用）
</code></pre>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12b4c5ee-5278-483d-95b6-d28f5fe28b9f.png"></p>
<h2 id="怎么存放热点数据"><a href="#怎么存放热点数据" class="headerlink" title="怎么存放热点数据"></a>怎么存放热点数据</h2><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1a7cbd81-1d25-49d2-9a27-e741e24b0af4.png"></p>
<h2 id="RDB-和-AOF-持久化"><a href="#RDB-和-AOF-持久化" class="headerlink" title="RDB 和 AOF 持久化"></a>RDB 和 AOF 持久化</h2><p>RDB（快照）持久化:保存某个时间点的全量数据快照。<br>优先：文件小，恢复快。（因为aof直接保存下来了指令(体积大)，恢复的时候也是直接执行这些指令(恢复慢)）。<br>缺点是：1. 内存数据一次性全量同步，由于数据量大同步IO时会影响性能。2. 丢失数据时数据量较大。</p>
<p>AOF(append-only file):保存写状态。（append除查询的SQL）</p>
<p>Redis持久化默认为RDB持久化。若需要AOF，则把append-only参数改成yes</p>
<h2 id="缓存雪崩和缓存穿透"><a href="#缓存雪崩和缓存穿透" class="headerlink" title="缓存雪崩和缓存穿透"></a>缓存雪崩和缓存穿透</h2><blockquote>
<p>redis的所有keys必须有过期时间（除了常量需要由手动触发更新外）</p>
</blockquote>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/834b6f6b-3a66-4058-86b3-8ecfd3fb7d58.jpg"></p>
<p><strong>缓存雪崩</strong>(缓存崩了)：缓存同一时间keys大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方法：<br><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/47c4b784-433e-4958-9869-6ae3b6586035.jpg"></p>
<p>即集群-限流/降级/加锁/布隆过滤器/<strong>exTime过期时间随机值</strong>，再使用aof,rdb恢复。</p>
<p><strong>缓存穿透</strong>(缓存没问题，是有意为之)：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方法：先使用<strong>布隆过滤器</strong>(限流，即流量控制)，再缓存结果(即便这个结果可能为空)。</p>
<p>布隆过滤器<br><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/img.png" alt="img.png"></p>
<h2 id="如何使用Redis做异步队列"><a href="#如何使用Redis做异步队列" class="headerlink" title="如何使用Redis做异步队列"></a>如何使用Redis做异步队列</h2><p>使用List作为队列，rpush生产消息，lpop消费消息。(先进先出)<br>nonono!<br>pub/sub: 发布订阅模式，如下图：<br><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19415199-1e04-4339-afe8-1e0b0c634ec9.jpg"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>大量key同时过期，由于清除key需要时间，所以会出现短暂的卡顿现象。可在设置过期时间的时候给每个key加上随机值。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol>
<li>singleton(默认值) </li>
<li>prototype <code>@Scope(&quot;prototype&quot;)</code></li>
<li>request</li>
<li>session</li>
</ol>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>与MySQL类似，有read uncommited，read commited，repeatable read(默认)，serializable。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use the default isolation level of the underlying datastore.</span></span><br><span class="line"><span class="comment">     * All other levels correspond to the JDBC isolation levels.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.sql.Connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant indicating that dirty reads, non-repeatable reads and phantom reads</span></span><br><span class="line"><span class="comment">     * can occur. This level allows a row changed by one transaction to be read by</span></span><br><span class="line"><span class="comment">     * another transaction before any changes in that row have been committed</span></span><br><span class="line"><span class="comment">     * (a &quot;dirty read&quot;). If any of the changes are rolled back, the second</span></span><br><span class="line"><span class="comment">     * transaction will have retrieved an invalid row.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant indicating that dirty reads are prevented; non-repeatable reads</span></span><br><span class="line"><span class="comment">     * and phantom reads can occur. This level only prohibits a transaction</span></span><br><span class="line"><span class="comment">     * from reading a row with uncommitted changes in it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant indicating that dirty reads and non-repeatable reads are</span></span><br><span class="line"><span class="comment">     * prevented; phantom reads can occur. This level prohibits a transaction</span></span><br><span class="line"><span class="comment">     * from reading a row with uncommitted changes in it, and it also prohibits</span></span><br><span class="line"><span class="comment">     * the situation where one transaction reads a row, a second transaction</span></span><br><span class="line"><span class="comment">     * alters the row, and the first transaction rereads the row, getting</span></span><br><span class="line"><span class="comment">     * different values the second time (a &quot;non-repeatable read&quot;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_REPEATABLE_READ</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant indicating that dirty reads, non-repeatable reads and phantom</span></span><br><span class="line"><span class="comment">     * reads are prevented. This level includes the prohibitions in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ISOLATION_REPEATABLE_READ&#125; and further prohibits the situation</span></span><br><span class="line"><span class="comment">     * where one transaction reads all rows that satisfy a &#123;<span class="doctag">@code</span> WHERE&#125;</span></span><br><span class="line"><span class="comment">     * condition, a second transaction inserts a row that satisfies that</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> WHERE&#125; condition, and the first transaction rereads for the</span></span><br><span class="line"><span class="comment">     * same condition, retrieving the additional &quot;phantom&quot; row in the second read.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.sql.Connection#TRANSACTION_SERIALIZABLE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>支持当前事务(当前存在事务，则加入该事务；如果没有则如下：)</p>
</blockquote>
<ol>
<li>TransactionDefinition.PROPAGATION_REQUIRED: 创建一个新事务。</li>
<li>supports：以非事务的方式继续运行。</li>
<li>mandatory：抛出异常。</li>
</ol>
<blockquote>
<p>不支持当前事务</p>
</blockquote>
<ol>
<li>requires_new: 创建一个新事务，挂起当前事务（若有）。</li>
<li>not_supported: 以非事务方式运行，挂起当前事务（若有）</li>
<li>never: 以非事务方式运行，抛出异常（若有）</li>
</ol>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Support a current transaction, create a new one if none exists.</span></span><br><span class="line"><span class="comment">     * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This is the default setting of a transaction annotation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Support a current transaction, execute non-transactionally if none exists.</span></span><br><span class="line"><span class="comment">     * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span></span><br><span class="line"><span class="comment">     * as it defines a transaction scope that synchronization will apply for.</span></span><br><span class="line"><span class="comment">     * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span></span><br><span class="line"><span class="comment">     * will be shared for the entire specified scope. Note that this depends on</span></span><br><span class="line"><span class="comment">     * the actual synchronization configuration of the transaction manager.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Support a current transaction, throw an exception if none exists.</span></span><br><span class="line"><span class="comment">     * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new transaction, and suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">     * Analogous to the EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">     * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">     * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">     * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute non-transactionally, suspend the current transaction if one exists.</span></span><br><span class="line"><span class="comment">     * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span></span><br><span class="line"><span class="comment">     * on all transaction managers. This in particular applies to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span></span><br><span class="line"><span class="comment">     * which requires the &#123;<span class="doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span></span><br><span class="line"><span class="comment">     * made available to it (which is server-specific in standard Java EE).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute non-transactionally, throw an exception if a transaction exists.</span></span><br><span class="line"><span class="comment">     * Analogous to EJB transaction attribute of the same name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute within a nested transaction if a current transaction exists,</span></span><br><span class="line"><span class="comment">     * behave like &#123;<span class="doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span></span><br><span class="line"><span class="comment">     * transaction managers. Out of the box, this only applies to the JDBC</span></span><br><span class="line"><span class="comment">     * DataSourceTransactionManager. Some JTA providers might support nested</span></span><br><span class="line"><span class="comment">     * transactions as well.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring-MVC-运行流程"><a href="#Spring-MVC-运行流程" class="headerlink" title="Spring MVC 运行流程"></a>Spring MVC 运行流程</h1><p>Request-&gt;DispatcherServlet-&gt;HandlerMapping-&gt;HandlerAdaper(Controller)-ViewResolver</p>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><strong>如何排序10G的数据？</strong></p>
<p>首先，数据量较大无法一次加载到内存，故需要对数据进行分段，分发到各个节点排序，最后再归并节点。因此可以采用k路归并算法，并结合缓冲区和iterable<T>。</p>
<h2 id="集合类框架"><a href="#集合类框架" class="headerlink" title="集合类框架"></a>集合类框架</h2><h3 id="List的常用方法及注意事项"><a href="#List的常用方法及注意事项" class="headerlink" title="List的常用方法及注意事项"></a>List的常用方法及注意事项</h3><p>常用方法：</p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9a6124a1-a1af-4786-9cc3-14b1e94e2380.jpg"></p>
<p>注意事项：在对List遍历的时候不能进行删除或者修改等操作，否则会出现<code>ConcurrentModificationException</code>异常。(笔记一定要经常复习)</p>
<h3 id="Map的常用方法及注意事项"><a href="#Map的常用方法及注意事项" class="headerlink" title="Map的常用方法及注意事项"></a>Map的常用方法及注意事项</h3><p>常用方法：</p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/634b28bd-f0c8-4c57-b65f-ecd191bc3b21.jpg"></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。</p>
<p>可以想象为：资源=电脑，人=线程</p>
<h3 id="产生死锁的-4-个必要条件"><a href="#产生死锁的-4-个必要条件" class="headerlink" title="产生死锁的 4 个必要条件"></a>产生死锁的 4 个必要条件</h3><ol>
<li>互斥性(资源)：一个资源只能被一个线程占有。</li>
<li>请求和保持条件(A)：一个线程请求已被占有的资源发生阻塞时，自己占有的资源也不释放。</li>
<li>不可抢占(B)：线程无法剥夺被占用的资源。</li>
<li>循环等待(AB)：发生死锁时，线程进入死循环，永久阻塞。</li>
</ol>
<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>竞争不可抢占性资源</li>
<li>竞争可消耗资源</li>
<li>进程推进顺序不当</li>
</ol>
<h3 id="避免死锁的方法（根据产生的条件）"><a href="#避免死锁的方法（根据产生的条件）" class="headerlink" title="避免死锁的方法（根据产生的条件）"></a>避免死锁的方法（根据产生的条件）</h3><ol>
<li>破坏“请求和保持”条件：一次性申请所有需要的资源（请求）/申请资源前释放占有的资源（保持）。</li>
<li>破坏“不可抢占”条件：抢不到资源就释放自己占有的资源。</li>
<li>破坏“循环等待”条件：按顺序获取资源。</li>
</ol>
<p>即一次性占有所有电脑、拿不到电脑就把自己的也给别人、排队用。</p>
<h2 id="Java-反射机制"><a href="#Java-反射机制" class="headerlink" title="Java 反射机制"></a>Java 反射机制</h2><p>定义：<strong>动态</strong>(运行过程)获取类信息及调用方法的功能，称为反射。</p>
<p>反射的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class robotClass = Class.forName(<span class="string">&quot;com.example.demo.reflect.Robot&quot;</span>);</span><br><span class="line">        Robot robot = (Robot) robotClass.newInstance();</span><br><span class="line"></span><br><span class="line">        Method sayHi = robotClass.getDeclaredMethod(<span class="string">&quot;sayHi&quot;</span>, String.class);</span><br><span class="line">        sayHi.invoke(robot, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClassLoader-loadClass-和-Class-forName-的区别"><a href="#ClassLoader-loadClass-和-Class-forName-的区别" class="headerlink" title="ClassLoader.loadClass() 和 Class.forName() 的区别"></a>ClassLoader.loadClass() 和 Class.forName() 的区别</h3><p>虽然forName可以初始化类，但是使用loadClass可以实现懒加载(即需要使用的时候才对对象初始化)。其中MySQL Driver有static代码，需要初始化才能使用。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>两者的概念：进程是<strong>资源分配</strong>的最小单位，线程是<strong>CPU调度</strong>的最小单位。</p>
<p>区别：一个进程可能有多个线程；进程是一个独立的应用，有<strong>独立的地址空间</strong>；进程的切换开销大；</p>
<p>另外，一个线程挂掉可能会导致整个进程挂掉。Java采用单线程编程模型，每个进程对应一个JVM实例，多个线程共享JVM里的堆。</p>
<p><img src="https://i.loli.net/2021/04/14/2WY8NqZJc5kUvld.png" alt="2WY8NqZJc5kUvld"></p>
<p><img src="https://i.loli.net/2021/04/14/VSxY3tQWTqMpw1k.png" alt="VSxY3tQWTqMpw1k"></p>
<p>其中，PC为程序计数器；TLS为ThreadLocalStorage，用于线程间的数据隔离。</p>
<h2 id="如何排查和解决死锁"><a href="#如何排查和解决死锁" class="headerlink" title="如何排查和解决死锁"></a>如何排查和解决死锁</h2><p>使用jvisualvm查看哪些线程发生死锁。</p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c1c2dedc-be29-4e4c-a49f-84a72d0b5d23.jpg"></p>
<p>[强制]对多个资源、数据库表、对象同时加锁时，需要<strong>保持一致的加锁顺序</strong>，否则可能会 造成死锁。说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。</p>
<h2 id="如何排查和解决服务器CPU占用率100"><a href="#如何排查和解决服务器CPU占用率100" class="headerlink" title="如何排查和解决服务器CPU占用率100%"></a>如何排查和解决服务器CPU占用率100%</h2><ol>
<li><p>top命令查看CPU使用情况(如mysql进程等等的cpu使用率，死锁不一定占用cpu)。</p>
</li>
<li><p>再通过jvisualvm查看相关进程的信息。</p>
</li>
</ol>
<h2 id="有哪些工具能够快速查看线程使用情况"><a href="#有哪些工具能够快速查看线程使用情况" class="headerlink" title="有哪些工具能够快速查看线程使用情况"></a>有哪些工具能够快速查看线程使用情况</h2><h2 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h2><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9ee3aa13-cd44-491c-9db7-1524b5043d89.jpg"></p>
<h2 id="Thread线程相关"><a href="#Thread线程相关" class="headerlink" title="Thread线程相关"></a>Thread线程相关</h2><h3 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h3><p>创建线程时可实现Runnable接口或继承Thread类(重写run方法)，而Thread类实际上也是实现了Runnable接口的。<br>因类的单一继承原则，推荐使用Runnable接口。<br>另外，调用start方法不一定立即执行run方法，而仅仅是进入就绪状态，有可能需要等待线程获取资源后才能执行。</p>
<h3 id="如何实现处理线程的返回值-即保证线程的顺序执行（跟代码的顺序执行没关系）"><a href="#如何实现处理线程的返回值-即保证线程的顺序执行（跟代码的顺序执行没关系）" class="headerlink" title="如何实现处理线程的返回值(即保证线程的顺序执行（跟代码的顺序执行没关系）)"></a>如何实现处理线程的返回值(即保证线程的顺序执行（跟代码的顺序执行没关系）)</h3><p>a. 主线程等待法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleWait</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value; <span class="comment">// 不需要加 static 也能在本方法中使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="string">&quot;we have data now.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CycleWait wait = <span class="keyword">new</span> CycleWait();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(wait);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> == wait.value) &#123; <span class="comment">// 看这里</span></span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + wait.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. 使用Thread类的join()方法阻塞当前线程以等待子线程处理完毕</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleWait</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value; <span class="comment">// 不需要加 static 也能在本方法中使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="string">&quot;we have data now.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CycleWait wait = <span class="keyword">new</span> CycleWait();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(wait);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join(); <span class="comment">// 阻塞当前线程而不是自己==。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + wait.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c. 通过Callable接口实现：使用FutureTask或者Executor线程池接收Callable对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">if</span> (!task.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task has not finished, please wait!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;task return: &quot;</span> + task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08735d98-7666-46b2-8956-3779a2434d88.jpg"></p>
<h3 id="线程的6种状态"><a href="#线程的6种状态" class="headerlink" title="线程的6种状态"></a>线程的6种状态</h3><ol>
<li>NEW 新建</li>
<li>RUNANBLE 可运行/运行中</li>
<li>BLOCKED 阻塞：等待获取锁(资源)。</li>
<li>WAITING 无限期等待：没有对<code>Object.wait()</code>或<code>Thread.join()</code>方法设置Timeout。<br>因为wait让出锁，所以此时自己会变成等待状态。</li>
<li>TIMED_WAITING 限时等待</li>
<li>TERMINATED 结束：结束后不能再调用Thread.start()方法（即只能调用一次），否则会抛出异常。</li>
</ol>
<h3 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify 和 notifyAll 的区别"></a>notify 和 notifyAll 的区别</h3><p>notify随机唤醒一个等待锁的线程，notifyAll则唤醒所有等待资源锁的线程。</p>
<h3 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h3><p>调用interrupt方法():</p>
<ol>
<li>若线程处于阻塞状态，则抛出<code>InterruptedException</code>。</li>
<li>若线程处于正常活动状态，则不起作用。可以将该线程的<strong>中断标记</strong>(使用<code>volatile</code>修饰的变量)设置为 true/false.</li>
<li><code>Thread.stop()</code>方法，相当于电脑的强制关机。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. volatile 标记</span></span><br><span class="line"><span class="comment"> * 2. interrupt() 方法</span></span><br><span class="line"><span class="comment"> * 3. stop() 方法(已弃用)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mark = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread tickTop = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(mark) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        tickTop.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;即将结束&quot;</span>);</span><br><span class="line">        <span class="comment">// tickTop.stop();</span></span><br><span class="line">        <span class="comment">// tickTop.interrupt(); // useless</span></span><br><span class="line">        mark = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BIO、NIO-和-AIO-对比"><a href="#BIO、NIO-和-AIO-对比" class="headerlink" title="BIO、NIO 和 AIO 对比"></a>BIO、NIO 和 AIO 对比</h2><p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/e1e7d227-f2df-4721-ba26-aa64396c36f3.jpg"></p>
<h2 id="Spring-IOC-和-AOP"><a href="#Spring-IOC-和-AOP" class="headerlink" title="Spring IOC 和 AOP"></a>Spring IOC 和 AOP</h2><p>IOC(Inversion of Control，控制反转)：</p>
<h2 id="Interceptor和Filter的区别"><a href="#Interceptor和Filter的区别" class="headerlink" title="Interceptor和Filter的区别"></a>Interceptor和Filter的区别</h2><p>Interceptor拦截器是基于java<strong>反射</strong>机制实现，在action的生命周期中可以多次调用，而Filter基于<strong>函数回调</strong>实现，只能在容器初始化时被调用<strong>一次</strong>，但是Filter对所有的请求起作用(即作用<strong>范围</strong>更广)。</p>
<h2 id="创建对象的-4-种方法"><a href="#创建对象的-4-种方法" class="headerlink" title="创建对象的 4 种方法"></a>创建对象的 4 种方法</h2><ol>
<li>new</li>
<li>反射</li>
<li>Object.clone():需要重写clone方法，这是浅拷贝，即成员变量的引用与原对象是相同的。</li>
<li>反序列化(ObjectInputStream.readObject())</li>
</ol>
<h2 id="保存日志"><a href="#保存日志" class="headerlink" title="保存日志"></a>保存日志</h2><p>日志级别：error &gt; warn &gt; info &gt; debug</p>
<p><img src="/2021/02/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/75b6deb9-2960-4640-afb7-3963fe14f0f1.png"></p>
<p>日志配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">$&#123;spring.application.name&#125;.log</span></span><br><span class="line">  <span class="comment"># 日志文件超过 10MB 后，自动分片</span></span><br><span class="line">  <span class="attr">file.max-size:</span> <span class="string">10MB</span></span><br><span class="line">  <span class="comment"># 日志文件最多存放 10 天</span></span><br><span class="line">  <span class="attr">file.max-history:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span> <span class="comment"># DAO 层可以为 DEBUG 级别</span></span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java基础知识</p><p><a href="https://teamwang.cn/2021/02/28/Java基础知识/">https://teamwang.cn/2021/02/28/Java基础知识/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jacky</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-02-28</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-29</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/01/Concurrency%E5%B9%B6%E5%8F%91/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java并发编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/26/210226/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "D7nrmJ3xSHla6mxR3p0BrXqD-gzGzoHsz",
            appKey: "rGXO6glIn8ETvzytN7maFaoP",
            placeholder: "Leave your comments~",
            
            
            meta: ["nick"],
            pageSize: 10,
            lang: "en",
            visitor: true,
            highlight: true,
            
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一-数据类型"><span class="level-left"><span class="level-item">一 数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-数据类型"><span class="level-left"><span class="level-item">1.1 数据类型</span></span></a></li><li><a class="level is-mobile" href="#1-2-和-equals-的区别"><span class="level-left"><span class="level-item">1.2 == 和 equals 的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二-Thread"><span class="level-left"><span class="level-item">二 Thread</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-线程安全与数据同步"><span class="level-left"><span class="level-item">2.1 线程安全与数据同步</span></span></a></li><li><a class="level is-mobile" href="#2-2-锁"><span class="level-left"><span class="level-item">2.2 锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-悲观锁-amp-乐观锁"><span class="level-left"><span class="level-item">2.2.1 悲观锁 &amp; 乐观锁</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-Synchronized-和-Lock"><span class="level-left"><span class="level-item">2.2.2 Synchronized 和 Lock</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-自旋锁-自适应自旋锁"><span class="level-left"><span class="level-item">2.2.3 自旋锁/自适应自旋锁</span></span></a></li><li><a class="level is-mobile" href="#2-2-4-锁的状态：偏向锁-轻量级锁-重量级锁"><span class="level-left"><span class="level-item">2.2.4 锁的状态：偏向锁/轻量级锁/重量级锁</span></span></a></li><li><a class="level is-mobile" href="#2-2-5-分段锁-ConcurrentHashMap"><span class="level-left"><span class="level-item">2.2.5 分段锁 - ConcurrentHashMap</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-线程的五种状态"><span class="level-left"><span class="level-item">2.3 线程的五种状态</span></span></a></li><li><a class="level is-mobile" href="#2-4-线程间通信"><span class="level-left"><span class="level-item">2.4 线程间通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-4-1-同步阻塞和异步非阻塞消息处理的区别"><span class="level-left"><span class="level-item">2.4.1 同步阻塞和异步非阻塞消息处理的区别</span></span></a></li><li><a class="level is-mobile" href="#2-4-2-wait-and-notify-methods"><span class="level-left"><span class="level-item">2.4.2 wait() and notify() methods</span></span></a></li><li><a class="level is-mobile" href="#2-4-3-sleep-和-wait-方法的比较"><span class="level-left"><span class="level-item">2.4.3 sleep 和 wait 方法的比较</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-5-多线程间通信"><span class="level-left"><span class="level-item">2.5 多线程间通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-5-1-注意"><span class="level-left"><span class="level-item">2.5.1 注意</span></span></a></li><li><a class="level is-mobile" href="#2-5-2-Synchronized-隐式锁-关键字的缺陷"><span class="level-left"><span class="level-item">2.5.2 Synchronized (隐式锁)关键字的缺陷</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-6-类加载的过程"><span class="level-left"><span class="level-item">2.6 类加载的过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-6-1-过程简介"><span class="level-left"><span class="level-item">2.6.1 过程简介</span></span></a></li><li><a class="level is-mobile" href="#2-6-2-类的主动使用和被动使用"><span class="level-left"><span class="level-item">2.6.2 类的主动使用和被动使用</span></span></a></li><li><a class="level is-mobile" href="#2-6-3-类的加载过程详解"><span class="level-left"><span class="level-item">2.6.3 类的加载过程详解</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-7-线程上下文类加载器"><span class="level-left"><span class="level-item">2.7 线程上下文类加载器</span></span></a></li><li><a class="level is-mobile" href="#2-8-深入理解-volatile-关键字"><span class="level-left"><span class="level-item">2.8 深入理解 volatile 关键字</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-8-1-初始-volatile-关键字"><span class="level-left"><span class="level-item">2.8.1 初始 volatile 关键字</span></span></a></li><li><a class="level is-mobile" href="#2-8-2-并发编程的三个重要特性"><span class="level-left"><span class="level-item">2.8.2 并发编程的三个重要特性</span></span></a></li><li><a class="level is-mobile" href="#2-8-3-volatile的使用场景"><span class="level-left"><span class="level-item">2.8.3 volatile的使用场景</span></span></a></li><li><a class="level is-mobile" href="#2-8-4-7种单例模式的设计"><span class="level-left"><span class="level-item">2.8.4 7种单例模式的设计</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-9-多线程设计架构模式"><span class="level-left"><span class="level-item">2.9 多线程设计架构模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三-集合类"><span class="level-left"><span class="level-item">三 集合类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-Map-双列集合"><span class="level-left"><span class="level-item">3.1 Map (双列集合)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#HashMap扩容机制"><span class="level-left"><span class="level-item">HashMap扩容机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-Collection-单列集合"><span class="level-left"><span class="level-item">3.2 Collection (单列集合)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#a-List-有序"><span class="level-left"><span class="level-item">a. List (有序)</span></span></a></li><li><a class="level is-mobile" href="#b-Set-有序"><span class="level-left"><span class="level-item">b. Set (有序)</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四-零散知识"><span class="level-left"><span class="level-item">四 零散知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-java-关键字总结"><span class="level-left"><span class="level-item">1. java 关键字总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-final-关键字"><span class="level-left"><span class="level-item">1.1 final 关键字</span></span></a></li><li><a class="level is-mobile" href="#1-2-static-关键字"><span class="level-left"><span class="level-item">1.2 static 关键字</span></span></a></li><li><a class="level is-mobile" href="#1-3-this-关键字"><span class="level-left"><span class="level-item">1.3 this 关键字</span></span></a></li><li><a class="level is-mobile" href="#1-4-super-关键字"><span class="level-left"><span class="level-item">1.4 super 关键字</span></span></a></li><li><a class="level is-mobile" href="#1-5-attention"><span class="level-left"><span class="level-item">1.5 attention</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-抽象类和接口的区别"><span class="level-left"><span class="level-item">2. 抽象类和接口的区别</span></span></a></li><li><a class="level is-mobile" href="#3-Override-和-Overload-的区别"><span class="level-left"><span class="level-item">3. Override 和 Overload 的区别</span></span></a></li><li><a class="level is-mobile" href="#4-封装、继承和多态"><span class="level-left"><span class="level-item">4. 封装、继承和多态</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多态的描述"><span class="level-left"><span class="level-item">多态的描述</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-泛型"><span class="level-left"><span class="level-item">5. 泛型</span></span></a></li><li><a class="level is-mobile" href="#6-值传递-amp-引用传递"><span class="level-left"><span class="level-item">6. 值传递 &amp; 引用传递</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL相关"><span class="level-left"><span class="level-item">MySQL相关</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#三范式-amp-四特性"><span class="level-left"><span class="level-item">三范式&amp;四特性</span></span></a></li><li><a class="level is-mobile" href="#事务"><span class="level-left"><span class="level-item">事务</span></span></a></li><li><a class="level is-mobile" href="#索引"><span class="level-left"><span class="level-item">索引</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#索引的种类："><span class="level-left"><span class="level-item">索引的种类：</span></span></a></li><li><a class="level is-mobile" href="#索引使用的数据结构："><span class="level-left"><span class="level-item">索引使用的数据结构：</span></span></a></li><li><a class="level is-mobile" href="#最左匹配原则"><span class="level-left"><span class="level-item">最左匹配原则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#优化查询速度"><span class="level-left"><span class="level-item">优化查询速度</span></span></a></li><li><a class="level is-mobile" href="#部分语法"><span class="level-left"><span class="level-item">部分语法</span></span></a></li><li><a class="level is-mobile" href="#InnoDB-和-MyISAM-区别"><span class="level-left"><span class="level-item">InnoDB 和 MyISAM 区别</span></span></a></li><li><a class="level is-mobile" href="#注意问题"><span class="level-left"><span class="level-item">注意问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#时区"><span class="level-left"><span class="level-item">时区</span></span></a></li><li><a class="level is-mobile" href="#修改最大连接数"><span class="level-left"><span class="level-item">修改最大连接数</span></span></a></li><li><a class="level is-mobile" href="#8-小时连接自动失效"><span class="level-left"><span class="level-item">8 小时连接自动失效</span></span></a></li><li><a class="level is-mobile" href="#为什么要用自增id做主键"><span class="level-left"><span class="level-item">为什么要用自增id做主键</span></span></a></li><li><a class="level is-mobile" href="#聚簇索引-amp-非聚簇索引"><span class="level-left"><span class="level-item">聚簇索引 &amp; 非聚簇索引</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Redis-相关"><span class="level-left"><span class="level-item">Redis 相关</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-种数据结构"><span class="level-left"><span class="level-item">5 种数据结构</span></span></a></li><li><a class="level is-mobile" href="#内存淘汰策略"><span class="level-left"><span class="level-item">内存淘汰策略</span></span></a></li><li><a class="level is-mobile" href="#怎么存放热点数据"><span class="level-left"><span class="level-item">怎么存放热点数据</span></span></a></li><li><a class="level is-mobile" href="#RDB-和-AOF-持久化"><span class="level-left"><span class="level-item">RDB 和 AOF 持久化</span></span></a></li><li><a class="level is-mobile" href="#缓存雪崩和缓存穿透"><span class="level-left"><span class="level-item">缓存雪崩和缓存穿透</span></span></a></li><li><a class="level is-mobile" href="#如何使用Redis做异步队列"><span class="level-left"><span class="level-item">如何使用Redis做异步队列</span></span></a></li><li><a class="level is-mobile" href="#其它"><span class="level-left"><span class="level-item">其它</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Spring"><span class="level-left"><span class="level-item">Spring</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Bean的生命周期"><span class="level-left"><span class="level-item">Bean的生命周期</span></span></a></li><li><a class="level is-mobile" href="#事务隔离级别"><span class="level-left"><span class="level-item">事务隔离级别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概述"><span class="level-left"><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#源码"><span class="level-left"><span class="level-item">源码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务传播行为"><span class="level-left"><span class="level-item">事务传播行为</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概述-1"><span class="level-left"><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#源码-1"><span class="level-left"><span class="level-item">源码</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Spring-MVC-运行流程"><span class="level-left"><span class="level-item">Spring MVC 运行流程</span></span></a></li><li><a class="level is-mobile" href="#面试"><span class="level-left"><span class="level-item">面试</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#FAQ"><span class="level-left"><span class="level-item">FAQ</span></span></a></li><li><a class="level is-mobile" href="#集合类框架"><span class="level-left"><span class="level-item">集合类框架</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#List的常用方法及注意事项"><span class="level-left"><span class="level-item">List的常用方法及注意事项</span></span></a></li><li><a class="level is-mobile" href="#Map的常用方法及注意事项"><span class="level-left"><span class="level-item">Map的常用方法及注意事项</span></span></a></li></ul></li><li><a class="level is-mobile" href="#死锁"><span class="level-left"><span class="level-item">死锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义"><span class="level-left"><span class="level-item">定义</span></span></a></li><li><a class="level is-mobile" href="#产生死锁的-4-个必要条件"><span class="level-left"><span class="level-item">产生死锁的 4 个必要条件</span></span></a></li><li><a class="level is-mobile" href="#产生死锁的原因"><span class="level-left"><span class="level-item">产生死锁的原因</span></span></a></li><li><a class="level is-mobile" href="#避免死锁的方法（根据产生的条件）"><span class="level-left"><span class="level-item">避免死锁的方法（根据产生的条件）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java-反射机制"><span class="level-left"><span class="level-item">Java 反射机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ClassLoader-loadClass-和-Class-forName-的区别"><span class="level-left"><span class="level-item">ClassLoader.loadClass() 和 Class.forName() 的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java-内存模型"><span class="level-left"><span class="level-item">Java 内存模型</span></span></a></li><li><a class="level is-mobile" href="#进程和线程的区别"><span class="level-left"><span class="level-item">进程和线程的区别</span></span></a></li><li><a class="level is-mobile" href="#如何排查和解决死锁"><span class="level-left"><span class="level-item">如何排查和解决死锁</span></span></a></li><li><a class="level is-mobile" href="#如何排查和解决服务器CPU占用率100"><span class="level-left"><span class="level-item">如何排查和解决服务器CPU占用率100%</span></span></a></li><li><a class="level is-mobile" href="#有哪些工具能够快速查看线程使用情况"><span class="level-left"><span class="level-item">有哪些工具能够快速查看线程使用情况</span></span></a></li><li><a class="level is-mobile" href="#强软弱虚引用"><span class="level-left"><span class="level-item">强软弱虚引用</span></span></a></li><li><a class="level is-mobile" href="#Thread线程相关"><span class="level-left"><span class="level-item">Thread线程相关</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Thread和Runnable的关系"><span class="level-left"><span class="level-item">Thread和Runnable的关系</span></span></a></li><li><a class="level is-mobile" href="#如何实现处理线程的返回值-即保证线程的顺序执行（跟代码的顺序执行没关系）"><span class="level-left"><span class="level-item">如何实现处理线程的返回值(即保证线程的顺序执行（跟代码的顺序执行没关系）)</span></span></a></li><li><a class="level is-mobile" href="#线程的6种状态"><span class="level-left"><span class="level-item">线程的6种状态</span></span></a></li><li><a class="level is-mobile" href="#notify-和-notifyAll-的区别"><span class="level-left"><span class="level-item">notify 和 notifyAll 的区别</span></span></a></li><li><a class="level is-mobile" href="#如何中断线程"><span class="level-left"><span class="level-item">如何中断线程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#BIO、NIO-和-AIO-对比"><span class="level-left"><span class="level-item">BIO、NIO 和 AIO 对比</span></span></a></li><li><a class="level is-mobile" href="#Spring-IOC-和-AOP"><span class="level-left"><span class="level-item">Spring IOC 和 AOP</span></span></a></li><li><a class="level is-mobile" href="#Interceptor和Filter的区别"><span class="level-left"><span class="level-item">Interceptor和Filter的区别</span></span></a></li><li><a class="level is-mobile" href="#创建对象的-4-种方法"><span class="level-left"><span class="level-item">创建对象的 4 种方法</span></span></a></li><li><a class="level is-mobile" href="#保存日志"><span class="level-left"><span class="level-item">保存日志</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Jacky"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jacky</p><p class="is-size-6 is-block">(ง ˙o˙)ว</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/cloris-cc"><i class="fab fa-github"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span>&copy; 2021 Jacky</span>  <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备19098392号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/"><i class="fab fa-weibo"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/cloris-cc"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>